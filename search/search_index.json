{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Go codes","text":""},{"location":"01-basics/01-project-setup/01-create-and-run/","title":"Create and Run Go Project","text":""},{"location":"01-basics/01-project-setup/01-create-and-run/#create-a-go-project","title":"Create a Go Project","text":"<p>To create a new Go project, use the <code>go mod init &lt;project-name&gt;</code> command.</p> <pre><code>go mod init github.com/deependujha/my-go-project\n</code></pre> <p>This style of project name is recommended for Go projects.</p> <p>This will create a new directory named <code>my-project</code> with the following structure:</p> <pre><code>my-project/\n\u251c\u2500\u2500 go.mod\n\u2514\u2500\u2500 main.go\n</code></pre>"},{"location":"01-basics/01-project-setup/01-create-and-run/#run-the-project","title":"Run the Project","text":"<pre><code>go run .\n</code></pre> <ul> <li>If you use <code>go run main.go</code>, it will only run the <code>main.go</code> file. If you're importing other files, you need to use the <code>go run .</code> command. Else, use <code>go run main.go helper.go ...</code> to run multiple files.</li> </ul>"},{"location":"01-basics/01-project-setup/01-create-and-run/#build-the-project","title":"Build the Project","text":"<pre><code>go build .\n\n# --- OR ---\ngo build -o my-project\n</code></pre>"},{"location":"01-basics/01-project-setup/01-create-and-run/#install-external-packages","title":"Install external packages","text":"<pre><code>go get github.com/someuser/ext-go-package\n</code></pre> <ul> <li>This will install the package in the <code>go.mod</code> file and <code>go.sum</code> file.</li> </ul>"},{"location":"01-basics/01-project-setup/01-create-and-run/#install-external-go-executables-binaries","title":"Install external go executables binaries","text":"<pre><code>go install github.com/someuser/ext-go-executable\n</code></pre>"},{"location":"01-basics/01-project-setup/01-create-and-run/#gomod-vs-gosum","title":"<code>go.mod</code> vs <code>go.sum</code>","text":"Aspect go.mod go.sum Purpose Tracks direct dependencies and Go version. Verifies and locks exact versions and hashes. Editable Yes (manually or by Go tools). No (automatically maintained by Go tools). Contents Module names and versions. Module names, versions, and their checksums. Scope Focuses on top-level dependencies. Includes transitive dependencies. <p>Best Practices</p> <ul> <li>Commit both files to version control to ensure a consistent build environment.</li> <li>Regularly run <code>go mod tidy</code> to clean up unused dependencies and sync go.sum.</li> <li>Use go.sum as a security feature\u2014verify that dependencies haven\u2019t been altered.</li> </ul>"},{"location":"01-basics/01-project-setup/01-create-and-run/#go-mod-tidy-command","title":"<code>go mod tidy</code> command","text":"<ul> <li>Removes Unused Dependencies:</li> <li>Adds Missing Dependencies:</li> <li>Updates go.sum</li> </ul> <ul> <li><code>go mod tidy</code> is a Go command used to clean up and optimize your project's dependency files (go.mod and go.sum).</li> <li>It ensures that your module's dependency list is accurate and minimal, reflecting only the libraries and versions you truly need.</li> </ul>"},{"location":"01-basics/01-project-setup/01-create-and-run/#go-install","title":"<code>go install</code>","text":"<p>To install a local binary package, use the <code>go install</code> command.</p> <p>It installs the executable binary in the <code>$GOPATH/bin</code> directory. Mostly <code>~/go/bin</code> directory.</p> <pre><code>go install\n</code></pre>"},{"location":"01-basics/01-project-setup/02-packages-in-go/","title":"Packages in Go","text":"<p>A package in Go is a way to organize code and promote reusability. Every Go program is made up of at least one package, and the <code>main</code> package is required to create an executable.</p> <p>Keep in mind</p> <p>Each directory in a Go project should have the same package name.</p> <pre><code>myproject/\n  myproject.go # package myproject\n  dir_1/\n    a1.go # package alpha\n    a2.go # package alpha (same package name)\n  dir_2/\n    b1.go # package beta\n    b2.go # package beta (same package name)\n    dir_3/\n      c1.go # package gamma\n      c2.go # package gamma (same package name)\n</code></pre>"},{"location":"01-basics/01-project-setup/02-packages-in-go/#declaring-and-using-packages","title":"Declaring and Using Packages","text":""},{"location":"01-basics/01-project-setup/02-packages-in-go/#declaring-a-package","title":"Declaring a Package","text":"<p>Every Go file starts with a <code>package</code> declaration: <pre><code>package main\n</code></pre></p>"},{"location":"01-basics/01-project-setup/02-packages-in-go/#importing-packages","title":"Importing Packages","text":"<p>Use the <code>import</code> keyword to include packages: <pre><code>import \"fmt\"\n</code></pre></p> <p>For multiple imports: <pre><code>import (\n    \"fmt\"\n    \"math\"\n)\n</code></pre></p>"},{"location":"01-basics/01-project-setup/02-packages-in-go/#creating-and-using-custom-packages","title":"Creating and Using Custom Packages","text":""},{"location":"01-basics/01-project-setup/02-packages-in-go/#create-a-package","title":"Create a Package","text":"<ol> <li>Create a new directory (e.g., <code>mypackage</code>).</li> <li>Add a <code>.go</code> file with the package name:    <pre><code>// mypackage/mypackage.go\npackage mypackage\n\nimport \"fmt\"\n\nfunc SayHello(name string) {\n    fmt.Printf(\"Hello, %s!\\n\", name)\n}\n</code></pre></li> </ol>"},{"location":"01-basics/01-project-setup/02-packages-in-go/#use-the-custom-package","title":"Use the Custom Package","text":"<ol> <li> <p>In the main program, import your package:    <pre><code>// main.go\npackage main\n\nimport (\n    \"mypackage\"\n)\n\nfunc main() {\n    mypackage.SayHello(\"Deep\")\n}\n</code></pre></p> </li> <li> <p>Run the program:    <pre><code>go run .\n</code></pre></p> </li> </ol> <p>Warning</p> <p>The below command will not work, as all the executables have not been mentioned. <pre><code>go run main.go\n</code></pre> You can either use: <code>go run main.go mypkg/mypkg.go</code> or better <code>go run .</code></p>"},{"location":"01-basics/01-project-setup/02-packages-in-go/#package-visibility-exported-vs-unexported","title":"Package Visibility: Exported vs. Unexported","text":"<ul> <li>Exported identifiers (functions, variables, constants, types) start with an uppercase letter.</li> <li>Example: <code>SayHello</code> (accessible outside the package).</li> <li>Unexported identifiers start with a lowercase letter.</li> <li>Example: <code>helperFunc</code> (accessible only within the same package).</li> </ul>"},{"location":"01-basics/01-project-setup/02-packages-in-go/#example","title":"Example","text":"<pre><code>// mypackage/mypackage.go\npackage mypackage\n\nimport \"fmt\"\n\n// Exported\nfunc SayHello(name string) {\n    fmt.Printf(\"Hello, %s!\\n\", name)\n}\n\n// Unexported\nfunc helperFunc() {\n    fmt.Println(\"This is a helper function\")\n}\n</code></pre> <p>The function <code>helperFunc</code> cannot be used outside <code>mypackage</code>.</p>"},{"location":"01-basics/01-project-setup/02-packages-in-go/#package-initialization","title":"Package Initialization","text":"<p>You can define an <code>init</code> function in a package. This function runs automatically when the package is imported.</p>"},{"location":"01-basics/01-project-setup/02-packages-in-go/#example_1","title":"Example","text":"<pre><code>package mypackage\n\nimport \"fmt\"\n\nfunc init() {\n    fmt.Println(\"mypackage initialized!\")\n}\n</code></pre> <p>When the package is imported, the <code>init</code> function runs before any other code in the package.</p>"},{"location":"01-basics/01-project-setup/02-packages-in-go/#go-modules-and-packages","title":"Go Modules and Packages","text":"<p>Go modules make package management simple: 1. Initialize a module:    <pre><code>go mod init myproject\n</code></pre> 2. Go automatically manages dependencies when you import third-party packages.</p>"},{"location":"01-basics/01-project-setup/02-packages-in-go/#example-with-third-party-packages","title":"Example with Third-Party Packages","text":"<p>Install a package (e.g., <code>github.com/spf13/cobra</code>): <pre><code>go get github.com/spf13/cobra\n</code></pre></p> <p>Import and use it in your code: <pre><code>import \"github.com/spf13/cobra\"\n</code></pre></p>"},{"location":"01-basics/01-project-setup/02-packages-in-go/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Keep Packages Cohesive:    Each package should have a single responsibility.</p> </li> <li> <p>Avoid Circular Dependencies:    Packages should not depend on each other in a circular manner.</p> </li> <li> <p>Use <code>internal</code> for Private Packages:</p> </li> <li>The <code>internal</code> directory restricts the use of its packages to the parent module.</li> <li>Example:      <pre><code>project/\n  internal/\n    helper/\n      helper.go\n  main.go\n</code></pre></li> <li> <p>The <code>helper</code> package can only be used by code inside the <code>project</code> module.</p> </li> <li> <p>Document Your Package:    Add comments to exported functions, constants, and types. This helps tools like <code>godoc</code> generate documentation.</p> </li> </ol>"},{"location":"01-basics/01-project-setup/02-packages-in-go/#common-go-standard-library-packages","title":"Common Go Standard Library Packages","text":"Package Description <code>fmt</code> Formatting input/output. <code>os</code> OS-level functionality (files, environment vars). <code>time</code> Time and date manipulation. <code>net/http</code> HTTP client and server. <code>io</code> Input/output primitives. <code>math</code> Mathematical functions and constants. <code>sync</code> Synchronization primitives like mutexes. <code>context</code> Managing request contexts (e.g., cancellations)."},{"location":"01-basics/02-essential-constructs/01-variables/","title":"Variables in Go","text":""},{"location":"01-basics/02-essential-constructs/01-variables/#variable-declaration-initialization","title":"Variable Declaration &amp; Initialization","text":"<pre><code>// declare a variable first (with type), and then initialize it\nvar name string\nname = \"Deependu Jha\"\n\n// OR (declare and initialize in one line)\nvar name string = \"Deependu Jha\"\n\n// OR (declare and initialize in one line with walrus operator)\nname := \"Deependu Jha\" // walrus operator (declare and initialize in one line)\n</code></pre>"},{"location":"01-basics/02-essential-constructs/01-variables/#variable-types","title":"Variable Types","text":"Type Description <code>bool</code> Boolean type, can be <code>true</code> or <code>false</code>. <code>int</code> Integer type, can be positive or negative. <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code> Signed integer types, can be positive or negative. <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code> Unsigned integer types, can only be positive. <code>float32</code>, <code>float64</code> Floating-point types, can be positive or negative. <code>string</code> String type, can be empty. <code>[]byte</code> Byte slice type, can be empty."},{"location":"01-basics/02-essential-constructs/01-variables/#print-in-go","title":"Print in Go","text":"<pre><code>import \"fmt\"\n\nfunc main() {\n    fmt.Print(\"Hello, World!\\n\") // print without newline\n    fmt.Println(\"Hello, World!\") // print with newline\n    fmt.Printf(\"Hello, %s!\", \"World\") // print with format\n}\n</code></pre>"},{"location":"01-basics/02-essential-constructs/01-variables/#log-in-go","title":"Log in Go","text":"<pre><code>import \"log\"\n\nfunc main() {\n    log.Print(\"Hello, World!\\n\") // print without newline\n    log.Println(\"Hello, World!\") // print with newline\n    log.Printf(\"Hello, %s!\", \"World\") // print with format\n\n    log.Fatal(\"Fatal error!\") // logs and exits (os.exit(1))\n    log.Fatalf(\"Fatal error! %s\", \"World\") // logs and exits\n    log.Panic(\"Panic error!\") // logs and panics\n}\n</code></pre>"},{"location":"01-basics/02-essential-constructs/02-conditional-and-loops/","title":"Conditional and Loops in Go","text":""},{"location":"01-basics/02-essential-constructs/02-conditional-and-loops/#conditional-statements-if-else-if-else","title":"Conditional Statements (if, else if, else)","text":"<pre><code>num := 10\nnum_mod_3 := num % 3\n\nif num_mod_3 == 0 {\n    fmt.Println(\"Divisible by 3\")\n} else if num_mod_3 == 1 {\n    fmt.Println(\"Remainder 1 when divided by 3\")\n} else {\n    fmt.Println(\"Remainder 2 when divided by 3\")\n}\n</code></pre> <p><code>else if</code> and <code>else</code> should immediately follow preceeding <code>}</code></p> <p>below code will not compile. <code>Go\u2019s syntax enforces clean code structure</code>. <pre><code>if num_mod_3 == 0 {\n    fmt.Println(\"Divisible by 3\")\n}\nelse if num_mod_3 == 1 {\n    fmt.Println(\"Remainder 1 when divided by 3\")\n}\nelse {\n    fmt.Println(\"Remainder 2 when divided by 3\")\n}\n</code></pre></p>"},{"location":"01-basics/02-essential-constructs/02-conditional-and-loops/#switch-statement","title":"Switch Statement","text":"<ul> <li>Go only runs the selected case, not all the cases that follow.</li> <li>In effect, the break statement that is needed at the end of each case in those languages is provided automatically in Go.</li> <li>Another important difference is that Go's switch cases need not be constants, and the values involved need not be integers.</li> </ul> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"runtime\"\n)\n\nfunc main() {\n    fmt.Print(\"Go runs on \")\n    switch os := runtime.GOOS; os {\n    case \"darwin\":\n        fmt.Println(\"OS X.\")\n    case \"linux\":\n        fmt.Println(\"Linux.\")\n    default:\n        // freebsd, openbsd,\n        // plan9, windows...\n        fmt.Printf(\"%s.\\n\", os)\n    }\n}\n</code></pre>"},{"location":"01-basics/02-essential-constructs/02-conditional-and-loops/#loops","title":"Loops","text":"<pre><code>for i := 0; i &lt; 10; i++ {\n    fmt.Println(i)\n}\n</code></pre>"},{"location":"01-basics/02-essential-constructs/02-conditional-and-loops/#for-loop-with-range","title":"<code>for</code> loop with <code>range</code>","text":"<ul> <li>range form of the for loop iterates over a slice or map</li> </ul> <pre><code>var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}\n\nfor i, v := range pow {\n    fmt.Printf(\"2**%d = %d\\n\", i, v)\n}\n</code></pre> <p>performance penalty</p> <ul> <li>range on a slice passes the copy of the value (not a reference) by default, this affects performance for large slices or complex data types</li> <li>In cases where performance is critical, you might consider using an index-based loop to avoid the copy.</li> </ul>"},{"location":"01-basics/02-essential-constructs/02-conditional-and-loops/#for-loop-with-break","title":"<code>for</code> loop with <code>break</code>","text":"<pre><code>for i := 0; i &lt; 10; i++ {\n    if i == 5 {\n        break\n    }\n    fmt.Println(i)\n}\n</code></pre>"},{"location":"01-basics/02-essential-constructs/02-conditional-and-loops/#for-loop-with-continue","title":"<code>for</code> loop with <code>continue</code>","text":"<pre><code>for i := 0; i &lt; 10; i++ {\n    if i == 5 {\n        continue\n    }\n    fmt.Println(i)\n}\n</code></pre>"},{"location":"01-basics/02-essential-constructs/02-conditional-and-loops/#infinite-loop","title":"Infinite Loop","text":"<pre><code>for {\n    fmt.Println(\"Infinite loop\")\n}\n</code></pre>"},{"location":"01-basics/02-essential-constructs/03-functions/","title":"Functions in Go","text":"<ul> <li>Functions are <code>first-class citizens</code>, meaning they <code>can be passed around like any other variable</code>.</li> </ul>"},{"location":"01-basics/02-essential-constructs/03-functions/#basic-function-definition","title":"Basic Function Definition","text":"<p>In Go, a function is defined using the <code>func</code> keyword. It can take parameters and return values.</p> <pre><code>func main(){\n    a := 10\n    b := 20\n    fmt.Println(add(a, b))\n}\n\nfunc add(a, b int) int {\n    return a + b\n}\n</code></pre> <ul> <li>if multiple parameters are same, just comma separate them and in the end mention datatype</li> </ul>"},{"location":"01-basics/02-essential-constructs/03-functions/#multiple-return-values","title":"Multiple return values","text":"<pre><code>func swap(a, b int) (int, int) {\n    return b, a\n}\n\nfunc main(){\n    x, y := swap(1, 2)\n    fmt.Println(x, y) // Output: 2 1\n}\n</code></pre> <p><code>err != nil</code> concept</p> <p>This multi-return feature is heavily used by Gofers for error handling.</p> <ul> <li>First value is the success value, second value is the error value.</li> <li>If the function returns an error, the second value will be non-nil.</li> <li>If the function returns a value, the second value will be nil.</li> </ul> <pre><code>func divide(a, b int) (int, error) {\n    if b == 0 {\n        return 0, errors.New(\"division by zero\")\n    }\n    return a / b, nil\n}\n\nfunc main(){\n    x, err := divide(10, 2)\n    if err != nil {  // error occurred. Hnadle it.\n        fmt.Println(err)\n    } else {\n        fmt.Println(x)\n    }\n}\n</code></pre>"},{"location":"01-basics/02-essential-constructs/03-functions/#named-return-values","title":"Named Return Values","text":"<pre><code>func divide(a, b int) (result int, err error) {\n    if b == 0 {\n        err = fmt.Errorf(\"division by zero\")\n        return\n    }\n    result = a / b\n    return\n}\n</code></pre>"},{"location":"01-basics/02-essential-constructs/03-functions/#variadic-functions","title":"Variadic Functions","text":"<ul> <li>A variadic function allows you to pass a variable number of arguments of a specific type.</li> </ul> <pre><code>func sum(nums ...int) int {\n    total := 0\n    for _, num := range nums {\n        total += num\n    }\n    return total\n}\n\nfunc main() {\n    result := sum(1, 2, 3, 4, 5)\n    fmt.Println(result) // Output: 15\n}\n</code></pre>"},{"location":"01-basics/02-essential-constructs/03-functions/#defer-panic-and-recover","title":"Defer, Panic and Recover","text":""},{"location":"01-basics/02-essential-constructs/03-functions/#defer","title":"Defer","text":"<ul> <li>executes a statement just before the completion of the function</li> <li>if multiple defer statements are present, they are executed in reverse order (stack - LIFO)</li> <li>used as cleanup code, e.g., closing a file, releasing a lock, etc.</li> </ul> <pre><code>// output: counting, 3, 2, 1\n\nfunc defer_in_func() {\n    defer fmt.Println(\"1\")\n    defer fmt.Println(\"2\")\n    defer fmt.Println(\"3\")\n\n    fmt.Println(\"counting\")\n}\n</code></pre>"},{"location":"01-basics/02-essential-constructs/03-functions/#panic","title":"Panic","text":"<ul> <li>Panic is a built-in function that stops the ordinary flow of control and begins panicking.</li> <li>When the function F calls panic, execution of F stops, any deferred functions in F are executed normally, and then F returns to its caller.</li> <li>To the caller, F then behaves like a call to panic. The process continues up the stack until all functions in the current goroutine have returned, at which point the program crashes.</li> <li><code>Panics can be initiated by invoking panic directly. They can also be caused by runtime errors, such as out-of-bounds array accesses</code>.</li> </ul> <pre><code>func main() {\n    fmt.Println(\"hello\")\n    defer fmt.Println(\"deferred print\")\n    panic(\"panicked\")\n    fmt.Println(\"world\")\n}\n</code></pre>"},{"location":"01-basics/02-essential-constructs/03-functions/#recover","title":"Recover","text":"<ul> <li>Recover is a built-in function that regains control of a panicking goroutine.</li> <li>Recover is only useful inside deferred functions.</li> <li>During normal execution, a call to recover will return nil and have no other effect.</li> <li>If the current goroutine is panicking, a call to recover will capture the value given to panic and resume normal execution.</li> </ul> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    f()\n    fmt.Println(\"Returned normally from f.\")\n}\n\nfunc f() {\n    defer func() {\n        if r := recover(); r != nil {\n            fmt.Println(\"Recovered in f\", r)\n        }\n    }()\n    fmt.Println(\"Calling g.\")\n    g(0)\n    fmt.Println(\"Returned normally from g.\")\n}\n\nfunc g(i int) {\n    if i &gt; 3 {\n        fmt.Println(\"Panicking!\")\n        panic(fmt.Sprintf(\"%v\", i))\n    }\n    defer fmt.Println(\"Defer in g\", i)\n    fmt.Println(\"Printing in g\", i)\n    g(i + 1)\n}\n</code></pre>"},{"location":"01-basics/02-essential-constructs/03-functions/#functions-as-arguments","title":"functions as arguments","text":"<ul> <li>You can assign functions to variables, pass functions as arguments, and return them from other functions.</li> </ul> <pre><code>func multiply(a, b int) int {\n    return a * b\n}\n\nfunc applyOperation(a, b int, op func(int, int) int) int {\n    return op(a, b)\n}\n\nfunc main(){\n    result := applyOperation(5, 3, multiply)\n    fmt.Println(result) // Output: 15\n}\n</code></pre> <p><code>closure</code>/python type decorator functions in go</p> <p>We can use this feature as decorator function in go.</p> <pre><code>func add(a, b int) int {\n    return a + b\n}\n\nfunc fix_first_argument(a int, op func(int, int) int) func(int) int {\n    return func(b int) int{\n        return op(a, b)\n    }\n}\n\nfunc main(){\n    add_one := fix_first_argument(1, add)\n    result := add_one(5)\n    fmt.Println(result) // Output: 6\n}\n</code></pre>"},{"location":"01-basics/02-essential-constructs/03-functions/#closure-in-go","title":"Closure in Go","text":"<p>A closure is a function value that references variables from outside its body.</p> <ul> <li>The function may access and assign to the referenced variables; in this sense the function is \"bound\" to the variables.</li> </ul> <pre><code>package main\n\nimport \"fmt\"\n\nfunc adder() func(int) int {\n    sum := 0\n    return func(x int) int {\n        sum += x\n        return sum\n    }\n}\n\nfunc main() {\n    pos, neg := adder(), adder()\n    for i := 0; i &lt; 10; i++ {\n        fmt.Println(pos(i), neg(-2*i))\n    }\n}\n</code></pre>"},{"location":"01-basics/02-essential-constructs/03-functions/#anonymous-function-in-go","title":"Anonymous function in Go","text":"<ul> <li>a function that doesn\u2019t have a name</li> </ul> <pre><code>package main\nimport \"fmt\"\n\nfunc main() {\n    // Anonymous function (defined and called immediately)\n    func() {\n        fmt.Println(\"Welcome! to GeeksforGeeks\")\n    }()\n}\n</code></pre> <ul> <li>passing arguments to anonymous function</li> </ul> <pre><code>package main\nimport \"fmt\"\n\nfunc main() {\n    // Passing arguments in anonymous function\n    func(ele string) {\n        fmt.Println(ele)\n    }(\"GeeksforGeeks\")\n}\n</code></pre> <ul> <li>Assigning anonymous function to a Variable</li> </ul> <pre><code>package main\nimport \"fmt\"\n\nfunc main() {\n    // Assigning an anonymous function to a variable\n    value := func() {\n        fmt.Println(\"Welcome! to GeeksforGeeks\")\n    }\n    value()\n}\n</code></pre> <ul> <li>passing anonymous function as function argument</li> </ul> <pre><code>package main\nimport \"fmt\"\n\n// Passing anonymous function as an argument\nfunc GFG(i func(p, q string) string) {\n    fmt.Println(i(\"Geeks\", \"for\"))\n}\nfunc main() {\n    value := func(p, q string) string {\n        return p + q + \"Geeks\"\n    }\n    GFG(value)\n}\n</code></pre>"},{"location":"01-basics/02-essential-constructs/04-arrays-and-slices/","title":"Arrays and Slices in Go","text":""},{"location":"01-basics/02-essential-constructs/04-arrays-and-slices/#arrays","title":"Arrays","text":"<p>An array in Go is a fixed-size collection of elements of the same type.</p>"},{"location":"01-basics/02-essential-constructs/04-arrays-and-slices/#declaring-and-initializing-arrays","title":"Declaring and Initializing Arrays","text":"<pre><code>var arr [5]int // Declares an array of size 5 with zero values\nfmt.Println(arr) // Output: [0 0 0 0 0]\n\narr[0] = 10 // Assign value to an index\nfmt.Println(arr[0]) // Output: 10\n\n// Declare and initialize an array in one step\narr2 := [3]string{\"Go\", \"Python\", \"Java\"}\nfmt.Println(arr2) // Output: [Go Python Java]\n\n// Use `...` to let the compiler infer the size\narr3 := [...]int{1, 2, 3, 4}\nfmt.Println(arr3) // Output: [1 2 3 4]\n</code></pre>"},{"location":"01-basics/02-essential-constructs/04-arrays-and-slices/#slices","title":"Slices","text":"<p>A slice is a dynamically-sized, more flexible version of an array. It's a view into an underlying array.</p>"},{"location":"01-basics/02-essential-constructs/04-arrays-and-slices/#declaring-and-initializing-slices","title":"Declaring and Initializing Slices","text":"<pre><code>// Create a slice directly\nslice := []int{1, 2, 3, 4}\nfmt.Println(slice) // Output: [1 2 3 4]\n\n// Create a slice from an array\narr := [5]int{10, 20, 30, 40, 50}\nslice2 := arr[1:4] // Slices from index 1 to 3 (4 is excluded)\nfmt.Println(slice2) // Output: [20 30 40]\n\n// Create a slice with `make`\nslice3 := make([]int, 3) // Creates a slice of length 3\nfmt.Println(slice3) // Output: [0 0 0]\n</code></pre>"},{"location":"01-basics/02-essential-constructs/04-arrays-and-slices/#slice-operations","title":"Slice Operations","text":""},{"location":"01-basics/02-essential-constructs/04-arrays-and-slices/#append-elements-to-a-slice","title":"Append Elements to a Slice","text":"<pre><code>slice := []int{1, 2, 3}\nslice = append(slice, 4, 5)\nfmt.Println(slice) // Output: [1 2 3 4 5]\n</code></pre>"},{"location":"01-basics/02-essential-constructs/04-arrays-and-slices/#copy-a-slice","title":"Copy a Slice","text":"<pre><code>src := []int{1, 2, 3}\ndest := make([]int, len(src))\ncopy(dest, src)\nfmt.Println(dest) // Output: [1 2 3]\n</code></pre>"},{"location":"01-basics/02-essential-constructs/04-arrays-and-slices/#reslicing","title":"Reslicing","text":"<pre><code>slice := []int{1, 2, 3, 4, 5}\nreslice := slice[1:4]\nfmt.Println(reslice) // Output: [2 3 4]\n</code></pre>"},{"location":"01-basics/02-essential-constructs/04-arrays-and-slices/#useful-built-in-functions","title":"Useful Built-in Functions","text":""},{"location":"01-basics/02-essential-constructs/04-arrays-and-slices/#len","title":"<code>len</code>","text":"<p>Returns the length of an array or slice.</p> <pre><code>slice := []int{1, 2, 3, 4}\nfmt.Println(len(slice)) // Output: 4\n</code></pre>"},{"location":"01-basics/02-essential-constructs/04-arrays-and-slices/#cap","title":"<code>cap</code>","text":"<p>Returns the capacity of a slice (the maximum number of elements it can hold without reallocation).</p> <pre><code>slice := make([]int, 3, 5) // Length 3, Capacity 5\nfmt.Println(cap(slice)) // Output: 5\n</code></pre>"},{"location":"01-basics/02-essential-constructs/04-arrays-and-slices/#multidimensional-arrays-and-slices","title":"Multidimensional Arrays and Slices","text":""},{"location":"01-basics/02-essential-constructs/04-arrays-and-slices/#arrays_1","title":"Arrays","text":"<pre><code>matrix := [2][2]int{{1, 2}, {3, 4}}\nfmt.Println(matrix) // Output: [[1 2] [3 4]]\n</code></pre>"},{"location":"01-basics/02-essential-constructs/04-arrays-and-slices/#slices_1","title":"Slices","text":"<pre><code>matrix := [][]int{\n    {1, 2},\n    {3, 4},\n}\nfmt.Println(matrix) // Output: [[1 2] [3 4]]\n</code></pre>"},{"location":"01-basics/02-essential-constructs/04-arrays-and-slices/#actual-way-to-use-2d-array-in-go","title":"Actual way to use 2d array in go","text":"<ul> <li>There's no easy way to use 2d array in go.</li> <li>We need to create a slice of slices.</li> </ul> <pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    my_matrix := make([][]int, 3)\n    for i := range my_matrix {\n        my_matrix[i] = make([]int, 3)\n    }\n\n    fill_the_matrix(my_matrix)\n\n    // print matrix\n    print_matrix(my_matrix)\n}\n\n// fill in the matrix values\nfunc fill_the_matrix(mat [][]int) {\n    r := len(mat)\n    c := len(mat[0])\n\n    for i := 0; i &lt; r; i++ {\n        for j := 0; j &lt; c; j++ {\n            mat[i][j] = r*i + j + 1\n        }\n    }\n}\n\nfunc print_matrix(mat [][]int) {\n    r := len(mat)\n    c := len(mat[0])\n\n    for i := 0; i &lt; r; i++ {\n        for j := 0; j &lt; c; j++ {\n            fmt.Print(mat[i][j], \" \")\n        }\n        fmt.Println()\n    }\n}\n</code></pre>"},{"location":"01-basics/02-essential-constructs/04-arrays-and-slices/#important-points","title":"Important points","text":"<p>Some important points</p> <ul> <li>Any dimensional array in go is internally a 1-D array only.</li> <li>A slice is a descriptor for a contiguous segment of an underlying array and provides access to a numbered sequence of elements from that array.</li> <li>So, if we modify the underlying array, the slice will reflect the change.</li> <li>And, if we modify the slice, the underlying array will reflect the change.</li> </ul> <pre><code>    arr := [3]int{1,2,3}\n    sli := arr[1:2]\n\n    fmt.Println(\"arr: \", arr) // [1 2 3]\n    fmt.Println(\"slice: \", sli) // [2]\n\n    sli[0] = 5\n    fmt.Println(\"arr: \", arr) // [1 5 3]\n    fmt.Println(\"slice: \", sli) //[5]\n\n    arr[1] = 9\n    fmt.Println(\"arr: \", arr) // [1 9 3]\n    fmt.Println(\"slice: \", sli) // [9]\n</code></pre>"},{"location":"01-basics/02-essential-constructs/05-structs-methods-and-enums/","title":"Structs, Methods, and Enums in Go","text":""},{"location":"01-basics/02-essential-constructs/05-structs-methods-and-enums/#structs","title":"Structs","text":"<p>Structs are composite types that group together fields of different types.</p>"},{"location":"01-basics/02-essential-constructs/05-structs-methods-and-enums/#defining-and-using-structs","title":"Defining and Using Structs","text":"<pre><code>type Person struct {\n    Name string\n    Age  int\n}\n\n// Create an instance of a struct\np := Person{Name: \"John\", Age: 25}\nfmt.Println(p) // Output: {John 25}\n\n// Access or modify fields\nfmt.Println(p.Name) // Output: John\np.Age = 26\nfmt.Println(p.Age) // Output: 26\n</code></pre>"},{"location":"01-basics/02-essential-constructs/05-structs-methods-and-enums/#anonymous-structs","title":"Anonymous Structs","text":"<p>You can define structs without giving them a name.</p> <pre><code>emp := struct {\n    ID   int\n    Role string\n}{ID: 101, Role: \"Developer\"}\nfmt.Println(emp) // Output: {101 Developer}\n</code></pre>"},{"location":"01-basics/02-essential-constructs/05-structs-methods-and-enums/#methods","title":"Methods","text":"<p>A method is a function with a receiver, enabling you to associate behavior with structs.</p>"},{"location":"01-basics/02-essential-constructs/05-structs-methods-and-enums/#defining-methods","title":"Defining Methods","text":"<pre><code>type Circle struct {\n    Radius float64\n}\n\n// Method with a value receiver\nfunc (c Circle) Area() float64 {\n    return 3.14 * c.Radius * c.Radius\n}\n\n// Method with a pointer receiver\nfunc (c *Circle) SetRadius(r float64) {\n    c.Radius = r\n}\n</code></pre>"},{"location":"01-basics/02-essential-constructs/05-structs-methods-and-enums/#using-methods","title":"Using Methods","text":"<pre><code>c := Circle{Radius: 5}\n\n// Call a value receiver method\nfmt.Println(c.Area()) // Output: 78.5\n\n// Call a pointer receiver method\nc.SetRadius(10)\nfmt.Println(c.Area()) // Output: 314\n</code></pre>"},{"location":"01-basics/02-essential-constructs/05-structs-methods-and-enums/#pointer-vs-value-receivers","title":"Pointer vs. Value Receivers","text":"<ul> <li>Value Receiver: A copy of the struct is passed, and changes don't affect the original struct.</li> <li>Pointer Receiver: A pointer to the struct is passed, allowing modifications to the original struct.</li> </ul>"},{"location":"01-basics/02-essential-constructs/05-structs-methods-and-enums/#enums-using-iota","title":"Enums (using iota)","text":"<p>Go doesn\u2019t have a native <code>enum</code> type, but you can mimic enums using <code>const</code> and <code>iota</code>.</p> <ul> <li><code>iota</code> is a special constant that starts at 0 and increments by 1 for each new constant.</li> <li>It\u2019s common to use <code>iota</code> with <code>const</code> to define a set of related constants.</li> </ul>"},{"location":"01-basics/02-essential-constructs/05-structs-methods-and-enums/#basic-enum-like-behavior","title":"Basic Enum-like Behavior","text":"<pre><code>type Status int\n\nconst (\n    Pending Status = iota\n    Approved\n    Rejected\n)\n\n// Usage\nstatus := Pending\nfmt.Println(status) // Output: 0\n\nif status == Pending {\n    fmt.Println(\"Status is pending.\")\n}\n</code></pre>"},{"location":"01-basics/02-essential-constructs/05-structs-methods-and-enums/#custom-string-representation-for-enums","title":"Custom String Representation for Enums","text":"<p>You can add a <code>String</code> method to your custom enum type.</p> <pre><code>func (s Status) String() string {\n    return [...]string{\"Pending\", \"Approved\", \"Rejected\"}[s]\n}\n\n// Usage\nfmt.Println(Pending) // Output: Pending\nfmt.Println(Approved) // Output: Approved\n</code></pre>"},{"location":"01-basics/02-essential-constructs/05-structs-methods-and-enums/#combining-structs-methods-and-enums","title":"Combining Structs, Methods, and Enums","text":"<p>Here\u2019s an example bringing everything together:</p> <pre><code>type Task struct {\n    ID     int\n    Title  string\n    Status Status\n}\n\nfunc (t Task) Display() {\n    fmt.Printf(\"Task #%d: %s - %s\\n\", t.ID, t.Title, t.Status)\n}\n\nfunc (t *Task) UpdateStatus(newStatus Status) {\n    t.Status = newStatus\n}\n\n// Usage\nfunc main() {\n    task := Task{ID: 1, Title: \"Write Go notes\", Status: Pending}\n    task.Display() // Output: Task #1: Write Go notes - Pending\n\n    task.UpdateStatus(Approved)\n    task.Display() // Output: Task #1: Write Go notes - Approved\n}\n</code></pre>"},{"location":"01-basics/02-essential-constructs/05-structs-methods-and-enums/#key-points","title":"Key Points","text":"<ul> <li>Structs: Use to group related data.</li> <li>Methods: Add behavior to structs. Use pointer receivers when you need to modify the struct.</li> <li>Enums: Mimic enums with <code>const</code> and <code>iota</code>. Add string representations for better readability.</li> </ul>"},{"location":"01-basics/02-essential-constructs/05-structs-methods-and-enums/#iota-in-action","title":"<code>iota</code> in action","text":""},{"location":"01-basics/02-essential-constructs/06-maps-in-go/","title":"Maps in Go","text":""},{"location":"01-basics/02-essential-constructs/06-maps-in-go/#what-is-a-map","title":"What is a Map?","text":"<p>A map is a collection of key-value pairs where each key is unique, and you can retrieve a value using its key.</p> <p>What about sets in Go?</p> <p>Go doesn\u2019t have a built-in set type. You can use a map with a value of <code>nil/boolean</code> to simulate a set.</p>"},{"location":"01-basics/02-essential-constructs/06-maps-in-go/#declaring-and-initializing-maps","title":"Declaring and Initializing Maps","text":""},{"location":"01-basics/02-essential-constructs/06-maps-in-go/#declaring-a-map","title":"Declaring a Map","text":"<pre><code>var m map[string]int // Declares a map without initializing\nfmt.Println(m)       // Output: map[]\nfmt.Println(m == nil) // Output: true\n</code></pre>"},{"location":"01-basics/02-essential-constructs/06-maps-in-go/#initializing-a-map","title":"Initializing a Map","text":"<pre><code>// Using make\nm := make(map[string]int)\nfmt.Println(m) // Output: map[]\n\n// Declaring and initializing in one step\nm2 := map[string]int{\n    \"Alice\": 25,\n    \"Bob\":   30,\n}\nfmt.Println(m2) // Output: map[Alice:25 Bob:30]\n</code></pre>"},{"location":"01-basics/02-essential-constructs/06-maps-in-go/#basic-operations-on-maps","title":"Basic Operations on Maps","text":""},{"location":"01-basics/02-essential-constructs/06-maps-in-go/#adding-or-updating-elements","title":"Adding or Updating Elements","text":"<pre><code>m := make(map[string]int)\nm[\"Alice\"] = 25 // Add a key-value pair\nm[\"Bob\"] = 30   // Add another pair\nm[\"Alice\"] = 26 // Update the value for the key \"Alice\"\nfmt.Println(m)  // Output: map[Alice:26 Bob:30]\n</code></pre>"},{"location":"01-basics/02-essential-constructs/06-maps-in-go/#accessing-values","title":"Accessing Values","text":"<pre><code>age := m[\"Alice\"]\nfmt.Println(age) // Output: 26\n</code></pre>"},{"location":"01-basics/02-essential-constructs/06-maps-in-go/#checking-if-a-key-exists","title":"Checking if a Key Exists","text":"<pre><code>age, exists := m[\"Charlie\"]\nif exists {\n    fmt.Println(\"Charlie\u2019s age:\", age)\n} else {\n    fmt.Println(\"Charlie not found\") // Output: Charlie not found\n}\n</code></pre>"},{"location":"01-basics/02-essential-constructs/06-maps-in-go/#deleting-a-key","title":"Deleting a Key","text":"<pre><code>delete(m, \"Alice\")\nfmt.Println(m) // Output: map[Bob:30]\n</code></pre>"},{"location":"01-basics/02-essential-constructs/06-maps-in-go/#iterating-over-a-map","title":"Iterating Over a Map","text":"<pre><code>for key, value := range m {\n    fmt.Printf(\"%s: %d\\n\", key, value)\n}\n</code></pre>"},{"location":"01-basics/02-essential-constructs/06-maps-in-go/#length-of-a-map","title":"Length of a Map","text":"<pre><code>fmt.Println(len(m)) // Output: Number of key-value pairs\n</code></pre>"},{"location":"01-basics/02-essential-constructs/06-maps-in-go/#maps-as-function-arguments","title":"Maps as Function Arguments","text":"<p>Maps are reference types, so passing them to a function doesn\u2019t copy the map; it passes a reference.</p> <pre><code>func updateMap(m map[string]int) {\n    m[\"Bob\"] = 35\n}\n\nm := map[string]int{\"Bob\": 30}\nupdateMap(m)\nfmt.Println(m[\"Bob\"]) // Output: 35\n</code></pre>"},{"location":"01-basics/02-essential-constructs/06-maps-in-go/#maps-of-structs","title":"Maps of Structs","text":"<pre><code>type Person struct {\n    Name string\n    Age  int\n}\n\npeople := map[string]Person{\n    \"Alice\": {Name: \"Alice\", Age: 25},\n    \"Bob\":   {Name: \"Bob\", Age: 30},\n}\nfmt.Println(people[\"Alice\"]) // Output: {Alice 25}\n</code></pre>"},{"location":"01-basics/02-essential-constructs/06-maps-in-go/#key-points","title":"Key Points","text":"<ol> <li>Maps are reference types and are automatically garbage collected.</li> <li>Use <code>make</code> to initialize maps. Uninitialized maps will cause a runtime panic on writes.</li> <li>Keys must be of a type that is comparable (e.g., numbers, strings, structs without slices or maps).</li> <li>Maps are not safe for concurrent use; use synchronization primitives like <code>sync.Mutex</code> or <code>sync.Map</code> for concurrent scenarios.</li> </ol>"},{"location":"01-basics/02-essential-constructs/07-struct-tags/","title":"Struct Tags","text":"<p>Struct tags are small pieces of metadata attached to fields of a struct that provide instructions to other Go code that works with the struct.</p>"},{"location":"01-basics/02-essential-constructs/07-struct-tags/#basic-usage","title":"Basic Usage","text":"<ul> <li>Go struct tags are annotations that appear after the type in a Go struct declaration.</li> <li>Each tag is composed of short strings associated with some corresponding value.</li> <li>A struct tag looks like this, with the tag offset with backtick ` characters.</li> </ul> <pre><code>type User struct {\n    Name string `example:\"name\"`\n}\n</code></pre> <ul> <li>Other Go code is then capable of examining these structs and extracting the values assigned to specific keys it requests.</li> <li>Struct tags have no effect on the operation of your code without additional code that examines them.</li> </ul>"},{"location":"01-basics/02-essential-constructs/07-struct-tags/#encoding-json","title":"Encoding json","text":"<ul> <li>Struct tags can be used to encode JSON.</li> <li>The <code>json</code> tag is used to specify the name of the field when encoding to JSON.</li> <li>It can also be used to denote the field as private, which will exclude it from encoding.</li> <li>Or, omit this field in json if the value is empty.</li> </ul> <pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n    \"os\"\n    \"time\"\n)\n\ntype User struct {\n    Name          string    `json:\"name\"`\n    Password      string    `json:\"-\"` // ignore private field\n    PreferredFish []string  `json:\"preferredFish, omitempty\"` // omit if empty\n    CreatedAt     time.Time `json:\"createdAt\"`\n}\n\nfunc main() {\n    u := &amp;User{\n        Name:      \"Sammy the Shark\",\n        Password:  \"fisharegreat\",\n        CreatedAt: time.Now(),\n    }\n\n    out, err := json.MarshalIndent(u, \"\", \"  \")\n    if err != nil {\n        log.Println(err)\n        os.Exit(1)\n    }\n\n    fmt.Println(string(out))\n}\n</code></pre>"},{"location":"02-intermediate/03-std-library/","title":"Go Standard Library","text":""},{"location":"02-intermediate/03-std-library/#1-os-file-operations-environment-variables","title":"1. os (File Operations, Environment Variables)","text":"<p>File Operations:</p> <ul> <li><code>os.Open(name string) (*os.File, error)</code> \u2013 Opens a file for reading.</li> <li><code>os.Create(name string) (*os.File, error)</code> \u2013 Creates a new file for writing.</li> <li><code>file.Close()</code> \u2013 Closes the opened file.</li> <li><code>ioutil.ReadFile(filename string) ([]byte, error)</code> \u2013 Reads the entire content of the file into a byte slice.</li> <li><code>os.Remove(name string) error</code> \u2013 Deletes the specified file.</li> <li><code>os.Stat(name string) (os.FileInfo, error)</code> \u2013 Retrieves file information like size, permissions, etc.</li> </ul> <p>Environment Variables:</p> <ul> <li><code>os.Getenv(key string) string</code> \u2013 Gets the value of the environment variable.</li> <li><code>os.Setenv(key, value string) error</code> \u2013 Sets the value of the environment variable.</li> <li><code>os.Environ()</code> \u2013 Returns a list of all environment variables.</li> </ul>"},{"location":"02-intermediate/03-std-library/#2-nethttp-building-http-servers-clients","title":"2. net/http (Building HTTP Servers, Clients)","text":"<p>HTTP Server:</p> <ul> <li><code>http.HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))</code> \u2013 Register a handler function for the given pattern.</li> <li><code>http.ListenAndServe(addr string, handler http.Handler) error</code> \u2013 Starts an HTTP server at the specified address.</li> <li>Example:   <pre><code>http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n  fmt.Fprintf(w, \"Hello, world!\")\n})\nlog.Fatal(http.ListenAndServe(\":8080\", nil))\n</code></pre></li> </ul> <p>HTTP Client:</p> <ul> <li><code>http.Get(url string) (*http.Response, error)</code> \u2013 Sends a GET request.</li> <li><code>http.Post(url, contentType string, body io.Reader) (*http.Response, error)</code> \u2013 Sends a POST request.</li> <li><code>http.NewRequest(method, url string, body io.Reader) (*http.Request, error)</code> \u2013 Creates a new HTTP request (useful for custom headers, etc.).</li> <li>Example:   <pre><code>resp, err := http.Get(\"https://example.com\")\nif err != nil {\n    log.Fatal(err)\n}\ndefer resp.Body.Close()\n</code></pre></li> </ul>"},{"location":"02-intermediate/03-std-library/#3-encodingjson-json-marshallingunmarshalling","title":"3. encoding/json (JSON Marshalling/Unmarshalling)","text":"<p>Marshalling (Go struct to JSON):</p> <ul> <li><code>json.Marshal(v interface{}) ([]byte, error)</code> \u2013 Converts Go values to JSON.</li> <li>Example:   <pre><code>person := struct {\n    Name string\n    Age  int\n}{\"Alice\", 30}\njsonData, _ := json.Marshal(person)\n</code></pre></li> </ul> <p>Unmarshalling (JSON to Go struct):</p> <ul> <li><code>json.Unmarshal(data []byte, v interface{}) error</code> \u2013 Converts JSON back to Go values.</li> <li>Example:   <pre><code>jsonStr := `{\"Name\":\"Alice\",\"Age\":30}`\nvar person struct {\n    Name string\n    Age  int\n}\njson.Unmarshal([]byte(jsonStr), &amp;person)\n</code></pre></li> </ul>"},{"location":"02-intermediate/03-std-library/#4-strconv-type-conversions","title":"4. strconv (Type Conversions)","text":"<p>String to Int/Float:</p> <ul> <li><code>strconv.Atoi(s string) (int, error)</code> \u2013 Converts string to integer.</li> <li><code>strconv.ParseInt(s string, base, bitSize int) (int64, error)</code> \u2013 Converts string to integer with specified base and bit size.</li> <li><code>strconv.ParseFloat(s string, bitSize int) (float64, error)</code> \u2013 Converts string to float.</li> <li>Example:   <pre><code>num, _ := strconv.Atoi(\"42\")\n</code></pre></li> </ul> <p>Int/Float to String:</p> <ul> <li><code>strconv.Itoa(i int) string</code> \u2013 Converts integer to string.</li> <li><code>strconv.FormatFloat(f float64, fmt byte, prec, bitSize int) string</code> \u2013 Converts float to string.</li> <li>Example:   <pre><code>numStr := strconv.Itoa(42)\n</code></pre></li> </ul>"},{"location":"02-intermediate/03-std-library/#5-time-time-manipulation","title":"5. time (Time Manipulation)","text":"<p>Current Time:</p> <ul> <li><code>time.Now()</code> \u2013 Returns the current local time.</li> <li>Example:   <pre><code>t := time.Now()\nfmt.Println(t)\n</code></pre></li> </ul> <p>Formatting Time:</p> <ul> <li><code>t.Format(layout string) string</code> \u2013 Formats the time based on layout.</li> <li>Layout example: <code>2006-01-02 15:04:05</code></li> <li>Example:   <pre><code>fmt.Println(t.Format(\"2006-01-02 15:04:05\"))\n</code></pre></li> </ul> <p>Sleeping:</p> <ul> <li><code>time.Sleep(duration time.Duration)</code> \u2013 Pauses execution for the specified duration.</li> <li>Example:   <pre><code>time.Sleep(2 * time.Second)\n</code></pre></li> </ul> <p>Time Parsing:</p> <ul> <li><code>time.Parse(layout, value string) (Time, error)</code> \u2013 Parses a string into time.</li> <li>Example:   <pre><code>parsedTime, _ := time.Parse(\"2006-01-02\", \"2024-11-17\")\n</code></pre></li> </ul> <p>Duration:</p> <ul> <li><code>time.Duration</code> \u2013 Represents elapsed time.</li> <li><code>time.Second</code>, <code>time.Minute</code> etc., are constants representing durations.</li> </ul>"},{"location":"02-intermediate/04-error-handling/","title":"Error Handling in Go","text":"<p>Go doesn't have exceptions. Instead, it uses multiple return values, typically returning an error as the second value from a function.</p>"},{"location":"02-intermediate/04-error-handling/#1-error-type","title":"1. Error Type","text":"<p>Go's built-in <code>error</code> type is an interface: <pre><code>type error interface {\n    Error() string\n}\n</code></pre> This means any type that implements the <code>Error()</code> method satisfies the <code>error</code> interface.</p>"},{"location":"02-intermediate/04-error-handling/#2-common-error-handling-pattern","title":"2. Common Error Handling Pattern","text":"<p>Go functions often return two values: the result and an error. If the error is <code>nil</code>, the result is valid. If not, handle the error.</p> <p>Basic Example: <pre><code>result, err := someFunction()\nif err != nil {\n    fmt.Println(\"Error:\", err)\n    return\n}\n// Process result\n</code></pre></p> <p>Function Signature with Error: <pre><code>func someFunction() (string, error) {\n    // Do something, return an error if needed\n    if failureCondition {\n        return \"\", errors.New(\"something went wrong\")\n    }\n    return \"success\", nil\n}\n</code></pre></p>"},{"location":"02-intermediate/04-error-handling/#3-creating-custom-errors","title":"3. Creating Custom Errors","text":"<p>You can create custom error types by defining a new struct that implements the <code>error</code> interface.</p> <p>Example: <pre><code>type CustomError struct {\n    Code int\n    Msg  string\n}\n\nfunc (e *CustomError) Error() string {\n    return fmt.Sprintf(\"Error %d: %s\", e.Code, e.Msg)\n}\n\nfunc someFunction() error {\n    return &amp;CustomError{Code: 404, Msg: \"Not Found\"}\n}\n\nerr := someFunction()\nif err != nil {\n    fmt.Println(err)  // Prints: Error 404: Not Found\n}\n</code></pre></p>"},{"location":"02-intermediate/04-error-handling/#4-handling-multiple-errors","title":"4. Handling Multiple Errors","text":"<p>You can chain errors or wrap them with additional context using <code>fmt.Errorf</code> or <code>errors.Wrap</code> (from external libraries like <code>github.com/pkg/errors</code>).</p> <p>Wrapping Errors: <pre><code>if err != nil {\n    return fmt.Errorf(\"failed to process request: %w\", err)\n}\n</code></pre> The <code>%w</code> format verb allows you to wrap the original error to retain its context.</p> <p>Unwrapping Errors (Go 1.13+): <pre><code>if errors.Is(err, someSpecificError) {\n    // Handle specific error\n}\n</code></pre></p>"},{"location":"02-intermediate/04-error-handling/#5-error-checking","title":"5. Error Checking:","text":"<ul> <li> <p>Nil Check: Always check for <code>nil</code> before proceeding. <pre><code>if err != nil {\n    // Handle error\n}\n</code></pre></p> </li> <li> <p>Error Assertion: If the error is of a specific type, you can use type assertion. <pre><code>if customErr, ok := err.(*CustomError); ok {\n    fmt.Println(\"Custom Error:\", customErr.Code)\n}\n</code></pre></p> </li> </ul>"},{"location":"02-intermediate/04-error-handling/#6-best-practices","title":"6. Best Practices:","text":"<ul> <li>Early Return: If an error occurs, return early to avoid deeper nested logic.</li> <li>Error Messages: Provide clear, descriptive messages for easier debugging.</li> <li>Avoid Silent Failures: Don\u2019t ignore errors unless absolutely necessary (e.g., if an error is truly non-critical).</li> </ul>"},{"location":"02-intermediate/04-error-handling/#7-example","title":"7. Example:","text":"<pre><code>package main\n\nimport (\n    \"errors\"\n    \"fmt\"\n)\n\nfunc riskyFunction() (int, error) {\n    return 0, errors.New(\"something went wrong\")\n}\n\nfunc main() {\n    result, err := riskyFunction()\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n    fmt.Println(\"Result:\", result)\n}\n</code></pre> <p>Output: <pre><code>Error: something went wrong\n</code></pre></p>"},{"location":"02-intermediate/05-testing/","title":"Testing","text":""},{"location":"02-intermediate/05-testing/#1-basic-testing-in-go","title":"1. Basic Testing in Go","text":"<p>Go has a built-in testing framework in the <code>testing</code> package.</p> <ul> <li>Test needs to be in a file <code>*_test.go</code>.</li> <li>Test functions need to be prefixed with <code>Test</code>.</li> </ul> <p>Basic Test Example: <pre><code>package main\n\nimport \"testing\"\n\n// Function to be tested\nfunc Add(a, b int) int {\n    return a + b\n}\n\n// --- code in `add_test.go` file\n\n// Test function\nfunc TestAdd(t *testing.T) {\n    result := Add(2, 3)\n    expected := 5\n    if result != expected {\n        t.Errorf(\"Expected %d but got %d\", expected, result)\n    }\n}\n</code></pre> - The test function name must start with <code>Test</code> followed by the function being tested. - <code>t *testing.T</code> is passed to the test function to report errors. - <code>t.Errorf</code> is used to report a test failure.</p> <p>Run the tests: <pre><code>go test\n</code></pre></p>"},{"location":"02-intermediate/05-testing/#2-table-driven-tests","title":"2. Table-Driven Tests","text":"<p>Table-driven tests are a Go idiom for testing different inputs and expected results in a concise and easy-to-maintain format.</p> <pre><code>func TestAdd(t *testing.T) {\n    tests := []struct {\n        a, b     int\n        expected int\n    }{\n        {2, 3, 5},\n        {5, 7, 12},\n        {0, 0, 0},\n        {-1, 1, 0},\n    }\n\n    for _, tt := range tests {\n        t.Run(fmt.Sprintf(\"%d+%d\", tt.a, tt.b), func(t *testing.T) {\n            result := Add(tt.a, tt.b)\n            if result != tt.expected {\n                t.Errorf(\"Expected %d but got %d\", tt.expected, result)\n            }\n        })\n    }\n}\n</code></pre>"},{"location":"02-intermediate/05-testing/#3-testing-with-setup-and-teardown","title":"3. Testing with Setup and Teardown","text":"<p>You might need setup or teardown functions for initializing and cleaning up resources.</p> <p>Example with <code>testing.T</code> Setup: <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"testing\"\n)\n\nfunc setup() {\n    fmt.Println(\"Setting up\")\n}\n\nfunc teardown() {\n    fmt.Println(\"Tearing down\")\n}\n\nfunc TestAdd(t *testing.T) {\n    setup()\n    defer teardown() // Ensures teardown happens after test completes\n\n    result := Add(2, 3)\n    if result != 5 {\n        t.Errorf(\"Expected 5 but got %d\", result)\n    }\n}\n</code></pre></p>"},{"location":"02-intermediate/05-testing/#4-mocking-in-go","title":"4. Mocking in Go","text":"<p>Go doesn\u2019t have built-in mocking tools, but you can easily create mock implementations or use third-party libraries like <code>github.com/stretchr/testify/mock</code> for more complex mocking.</p>"},{"location":"02-intermediate/05-testing/#manual-mocking","title":"Manual Mocking","text":"<p>If you're testing a function that depends on an external interface or a database, you can create a manual mock.</p> <p>Example with Interface: <pre><code>package main\n\nimport \"testing\"\n\n// Define an interface\ntype Database interface {\n    Save(data string) error\n}\n\n// Implement a mock struct\ntype MockDatabase struct{}\n\nfunc (m *MockDatabase) Save(data string) error {\n    if data == \"\" {\n        return fmt.Errorf(\"empty data\")\n    }\n    return nil\n}\n\nfunc TestSaveData(t *testing.T) {\n    mockDB := &amp;MockDatabase{}\n    err := mockDB.Save(\"data\")\n    if err != nil {\n        t.Errorf(\"Expected no error but got %v\", err)\n    }\n\n    err = mockDB.Save(\"\")\n    if err == nil {\n        t.Error(\"Expected error for empty data\")\n    }\n}\n</code></pre></p>"},{"location":"02-intermediate/05-testing/#mocking-with-testifymock","title":"Mocking with <code>testify/mock</code>","text":"<p><code>testify</code> is a popular library for mocking and assertions. Install it via: <pre><code>go get github.com/stretchr/testify\n</code></pre></p> <p>Mock Example with <code>testify/mock</code>: <pre><code>package main\n\nimport (\n    \"testing\"\n    \"github.com/stretchr/testify/mock\"\n)\n\n// Define an interface\ntype Database interface {\n    Save(data string) error\n}\n\n// Define a mock struct using testify\ntype MockDatabase struct {\n    mock.Mock\n}\n\nfunc (m *MockDatabase) Save(data string) error {\n    args := m.Called(data)\n    return args.Error(0)\n}\n\n// Test function using the mock\nfunc TestSaveDataWithMock(t *testing.T) {\n    mockDB := new(MockDatabase)\n    mockDB.On(\"Save\", \"data\").Return(nil) // Mock behavior\n    mockDB.On(\"Save\", \"\").Return(fmt.Errorf(\"empty data\"))\n\n    err := mockDB.Save(\"data\")\n    if err != nil {\n        t.Errorf(\"Expected no error but got %v\", err)\n    }\n\n    err = mockDB.Save(\"\")\n    if err == nil {\n        t.Error(\"Expected error for empty data\")\n    }\n\n    mockDB.AssertExpectations(t) // Assert all expected calls were made\n}\n</code></pre></p> <p><code>testify/mock</code> allows you to: - Set expectations (<code>mockDB.On()</code>). - Verify that expectations were met (<code>mockDB.AssertExpectations()</code>).</p>"},{"location":"02-intermediate/05-testing/#5-benchmarking","title":"5. Benchmarking","text":"<p>Go also supports benchmarking with the <code>testing</code> package using the <code>Benchmark</code> function.</p> <p>Example: <pre><code>func BenchmarkAdd(b *testing.B) {\n    for i := 0; i &lt; b.N; i++ {\n        Add(2, 3)\n    }\n}\n</code></pre></p> <p>To run the benchmark: <pre><code>go test -bench .\n</code></pre></p> <p>Benchmarking Specific Functions: You can benchmark individual functions like this: <pre><code>go test -bench=BenchmarkAdd\n</code></pre></p>"},{"location":"02-intermediate/05-testing/#6-code-coverage","title":"6. Code Coverage","text":"<p>Go supports built-in code coverage.</p> <p>Run Tests with Coverage: <pre><code>go test -cover\n</code></pre></p> <p>Show Detailed Coverage: <pre><code>go test -coverprofile=coverage.out\ngo tool cover -html=coverage.out\n</code></pre></p> <p>This will generate a nice HTML file showing the code coverage details.</p>"},{"location":"02-intermediate/05-testing/#7-parallel-tests","title":"7. Parallel Tests","text":"<p>To run tests in parallel (useful for independent tests), you can use <code>t.Parallel()</code>.</p> <pre><code>func TestAdd1(t *testing.T) {\n    t.Parallel()  // Run this test in parallel with others\n    result := Add(2, 3)\n    if result != 5 {\n        t.Errorf(\"Expected 5 but got %d\", result)\n    }\n}\n\nfunc TestAdd2(t *testing.T) {\n    t.Parallel()\n    result := Add(5, 7)\n    if result != 12 {\n        t.Errorf(\"Expected 12 but got %d\", result)\n    }\n}\n</code></pre>"},{"location":"02-intermediate/05-testing/#8-test-suites-multiple-tests-for-the-same-group","title":"8. Test Suites (Multiple Tests for the Same Group)","text":"<p>Test suites aren\u2019t built-in, but you can group tests logically by creating a helper function for repeated setup or assertions.</p> <p>Test Suite Example: <pre><code>package main\n\nimport \"testing\"\n\nfunc setupSuite() {\n    // Setup code for the suite\n}\n\nfunc teardownSuite() {\n    // Cleanup code for the suite\n}\n\nfunc TestSuite(t *testing.T) {\n    setupSuite()\n    defer teardownSuite()\n\n    t.Run(\"TestCase1\", TestAdd1)\n    t.Run(\"TestCase2\", TestAdd2)\n}\n</code></pre></p>"},{"location":"02-intermediate/05-testing/#9-additional-testing-tools","title":"9. Additional Testing Tools","text":"<ul> <li>Test coverage tools: Like <code>go-coverage</code> for more advanced code coverage analysis.</li> <li>GoMock: Another popular mocking library (install via <code>go get github.com/golang/mock/gomock</code>).</li> <li>Testify Assertions: It\u2019s useful for easy assertions:   <pre><code>assert.Equal(t, expected, actual)\nassert.NoError(t, err)\n</code></pre></li> </ul>"},{"location":"02-intermediate/05-testing/#10-summary-of-testing-workflow","title":"10. Summary of Testing Workflow","text":"<ol> <li>Write a function to be tested.</li> <li>Write a test function that checks the behavior.</li> <li>Use assertions to check that the result matches expectations.</li> <li>Mock external dependencies if needed.</li> <li>Use <code>t.Parallel()</code> for concurrent testing.</li> <li>Benchmark critical parts of your code to ensure performance.</li> <li>Run tests using <code>go test</code>.</li> </ol>"},{"location":"02-intermediate/01-concurrency/01-goroutine/","title":"Concurrency in Go","text":""},{"location":"02-intermediate/01-concurrency/01-goroutine/#what-is-concurrency","title":"What is Concurrency?","text":"<p>Concurrency refers to the ability of a program to handle multiple tasks at the same time. In Go, this is primarily achieved using goroutines and channels.</p>"},{"location":"02-intermediate/01-concurrency/01-goroutine/#1-goroutines","title":"1. Goroutines","text":"<p>Goroutines are lightweight threads managed by the Go runtime. They are fundamental to concurrency in Go.</p> <ul> <li>How to create a Goroutine:</li> </ul> <p>A goroutine is created using the <code>go</code> keyword followed by a function call. </p> <pre><code>go myFunction() // Runs concurrently with the rest of the program\n</code></pre> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc printNumbers() {\n    for i := 1; i &lt;= 5; i++ {\n        fmt.Println(i)\n        time.Sleep(time.Second)\n    }\n}\n\nfunc main() {\n    go printNumbers() // Start the function in a goroutine\n\n    // Wait for goroutine to finish, \n    //else it will exit and thread will be killed\n    time.Sleep(6 * time.Second) \n}\n</code></pre>"},{"location":"02-intermediate/01-concurrency/01-goroutine/#2-waitgroup","title":"2. WaitGroup","text":"<p>A <code>sync.WaitGroup</code> is used to wait for a collection of goroutines to finish executing.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nfunc printMessage(i int, wg *sync.WaitGroup) {\n    defer wg.Done()\n    fmt.Printf(\"Message %d\\n\", i)\n}\n\nfunc main() {\n    var wg sync.WaitGroup\n\n    // Start 5 goroutines\n    for i := 1; i &lt;= 5; i++ {\n        wg.Add(1)\n        go printMessage(i, &amp;wg)\n    }\n\n    // Wait for all goroutines to finish\n    wg.Wait()\n}\n</code></pre>"},{"location":"02-intermediate/01-concurrency/01-goroutine/#3-channels","title":"3. Channels","text":"<p>Channels are used for communication between goroutines. They allow data to be passed between concurrent tasks safely.</p> <ul> <li>Once msg has been read from channel, it will be garbage collected.</li> <li> <p>If multiple goroutines are reading from the same channel, it can be read by any one of them only.</p> </li> <li> <p>Declaring a channel:</p> </li> </ul> <pre><code>ch := make(chan int) // Unbuffered channel for integers\n</code></pre> <ul> <li>Sending data to a channel:</li> </ul> <pre><code>ch &lt;- 42 // Send 42 to channel\n</code></pre> <ul> <li>Receiving data from a channel:</li> </ul> <pre><code>value := &lt;-ch // Receive data from channel\n</code></pre> <pre><code>package main\n\nimport \"fmt\"\n\nfunc sendData(ch chan int) { // running in goroutine\n    ch &lt;- 42\n}\n\nfunc main() {\n    ch := make(chan int)\n    go sendData(ch) // Run sendData in a goroutine\n    receivedValue := &lt;-ch // Receive value from channel (blocking)\n    fmt.Println(receivedValue) // Prints: 42\n}\n</code></pre> <ul> <li> <p>Buffered Channels:</p> </li> <li> <p>A buffered channel allows for asynchronous sending and receiving.</p> </li> <li>Channels with a buffer size can hold a specified number of elements before blocking.</li> <li>Even <code>goroutine</code> get blocked when channel is full (buffered channel)/ channel value is not read (in case of unbuffered channel)</li> </ul> <pre><code>ch := make(chan int, 2) // Create a buffered channel with capacity of 2\nch &lt;- 1\nch &lt;- 2\nfmt.Println(&lt;-ch) // Prints 1\nfmt.Println(&lt;-ch) // Prints 2\n</code></pre>"},{"location":"02-intermediate/01-concurrency/01-goroutine/#channel-direction","title":"Channel direction","text":"<p>When using channels as function parameters, you can specify if a channel is meant to only send or receive values. This specificity increases the type-safety of the program.</p> <pre><code>package main\n\nimport \"fmt\"\n\n// channel is meant to only receive values\nfunc ping(pings chan&lt;- string, msg string) {\n    pings &lt;- msg\n}\n\n// channel is meant to only send values\nfunc pong(pings &lt;-chan string, pongs chan&lt;- string) {\n    msg := &lt;-pings\n    pongs &lt;- msg\n}\n\nfunc main() {\n    pings := make(chan string, 1)\n    pongs := make(chan string, 1)\n    ping(pings, \"passed message\")\n    pong(pings, pongs)\n    fmt.Println(&lt;-pongs)\n}\n</code></pre>"},{"location":"02-intermediate/01-concurrency/01-goroutine/#4-select-statement","title":"4. Select Statement","text":"<p>The <code>select</code> statement allows you to wait on multiple channel operations. It\u2019s like a <code>switch</code> but for channels.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc sendData(ch chan string) {\n    time.Sleep(time.Second)\n    ch &lt;- \"Hello from goroutine\"\n}\n\nfunc main() {\n    ch := make(chan string)\n    go sendData(ch) // Run sendData in a goroutine\n\n    select {\n    case msg := &lt;-ch:\n        fmt.Println(msg) // Prints: Hello from goroutine\n    case &lt;-time.After(2 * time.Second):\n        fmt.Println(\"Timeout\")\n    }\n}\n</code></pre> <p>A better example, infinitely waiting for response from multiple channels, and if any time <code>quit channel</code> sends a message, it will exit the program.</p> <pre><code>package main\n\nimport \"fmt\"\n\nfunc fibonacci(c, quit chan int) {\n    x, y := 0, 1\n    for {\n        select {\n        case c &lt;- x:\n            x, y = y, x+y\n        case &lt;-quit:\n            fmt.Println(\"quit\")\n            return\n        }\n    }\n}\n\nfunc main() {\n    c := make(chan int)\n    quit := make(chan int)\n    go func() {\n        for i := 0; i &lt; 10; i++ {\n            fmt.Println(&lt;-c)\n        }\n        quit &lt;- 0\n    }()\n    fibonacci(c, quit)\n}\n</code></pre>"},{"location":"02-intermediate/01-concurrency/01-goroutine/#5-worker-pool","title":"5. Worker Pool","text":"<p>A worker pool is a pattern where you create a fixed number of workers (goroutines) that process tasks from a shared channel.</p> <p>Steps:</p> <ul> <li>Create a channel for tasks.</li> <li>Start a fixed number of worker goroutines.</li> <li>Workers listen on the task channel and process the tasks.</li> </ul> <p>Keep in mind</p> <ul> <li>Once msg has been read from channel, it will be garbage collected.</li> <li>If multiple goroutines are reading from the same channel, it can be read by any one of them only.</li> </ul> <pre><code>package main\n\nimport \"fmt\"\n\n// Task to be processed\ntype Task struct {\n    id int\n}\n\n// Worker function\nfunc worker(id int, tasks chan Task, done chan bool) {\n    for task := range tasks { // this range will keep reading from channel until it is closed\n        fmt.Printf(\"Worker %d is processing task %d\\n\", id, task.id)\n    }\n    done &lt;- true\n}\n\nfunc main() {\n    tasks := make(chan Task, 10)\n    done := make(chan bool)\n\n    // Create 3 workers\n    for i := 1; i &lt;= 3; i++ {\n        go worker(i, tasks, done)\n    }\n\n    // Send tasks to workers\n    for i := 1; i &lt;= 5; i++ {\n        tasks &lt;- Task{id: i}\n    }\n\n    // Close task channel\n    close(tasks)\n\n    // Wait for workers to finish\n    for i := 1; i &lt;= 3; i++ {\n        &lt;-done\n    }\n}\n</code></pre>"},{"location":"02-intermediate/01-concurrency/01-goroutine/#6-mutex-mutual-exclusion","title":"6. Mutex (Mutual Exclusion)","text":"<p>Mutexes are used for synchronizing access to shared resources to avoid race conditions.</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nvar counter int\nvar mu sync.Mutex\n\nfunc increment() {\n    mu.Lock()   // Lock the mutex\n    counter++   // Critical section\n    mu.Unlock() // Unlock the mutex\n}\n\nfunc main() {\n    for i := 0; i &lt; 1000; i++ {\n        go increment()\n    }\n\n    // Wait before printing the counter value\n    fmt.Println(counter) // Prints the final value of counter\n}\n</code></pre>"},{"location":"02-intermediate/01-concurrency/01-goroutine/#summary-of-concurrency-topics","title":"Summary of Concurrency Topics","text":"<ul> <li>Goroutines: Lightweight threads managed by the Go runtime.</li> <li>Channels: Communication between goroutines.</li> <li>Select: Wait on multiple channel operations.</li> <li>Worker Pool: Using multiple goroutines to process tasks.</li> <li>Mutexes: Synchronization primitives for mutual exclusion.</li> <li>WaitGroup: Wait for multiple goroutines to finish.</li> </ul>"},{"location":"02-intermediate/01-concurrency/02-context-in-go/","title":"Context in Go","text":"<p>The <code>context</code> package in Go provides a way to manage deadlines, cancellation signals, and other request-scoped values across API boundaries. It is widely used for concurrent programming and graceful termination of goroutines.</p>"},{"location":"02-intermediate/01-concurrency/02-context-in-go/#key-features-of-context","title":"Key Features of Context","text":"<ul> <li>Cancellation Propagation: Cancels all derived contexts when the parent context is canceled.</li> <li>Timeouts and Deadlines: Automatically cancel operations after a specified time.</li> <li>Request-Scoped Data: Pass values (like user IDs, session tokens) across API calls.</li> </ul>"},{"location":"02-intermediate/01-concurrency/02-context-in-go/#creating-contexts","title":"Creating Contexts","text":"<p>There are four main ways to create contexts:</p>"},{"location":"02-intermediate/01-concurrency/02-context-in-go/#contextbackground","title":"<code>context.Background()</code>","text":"<ul> <li>It\u2019s an empty context and acts as the root of any context tree.</li> <li>Typically used at the top level (e.g., in <code>main()</code> or request handlers).</li> </ul> <pre><code>ctx := context.Background()\n</code></pre>"},{"location":"02-intermediate/01-concurrency/02-context-in-go/#contexttodo","title":"<code>context.TODO()</code>","text":"<ul> <li>Used when you are unsure which context to use.</li> <li>A placeholder to indicate that you plan to use a proper context later.</li> </ul> <pre><code>ctx := context.TODO()\n</code></pre>"},{"location":"02-intermediate/01-concurrency/02-context-in-go/#contextwithcancelparentcontext","title":"<code>context.WithCancel(parentContext)</code>","text":"<ul> <li>Derives a new context that can be explicitly canceled.</li> </ul> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    // Create a context with cancel\n    ctx, cancel := context.WithCancel(context.Background())\n\n    go func(ctx context.Context) {\n        for {\n            select {\n            case &lt;-ctx.Done():\n                fmt.Println(\"Goroutine exiting...\")\n                return\n            default:\n                fmt.Println(\"Goroutine running...\")\n                time.Sleep(500 * time.Millisecond)\n            }\n        }\n    }(ctx)\n\n    time.Sleep(2 * time.Second)\n    cancel() // Cancel the context\n    time.Sleep(1 * time.Second)\n}\n</code></pre>"},{"location":"02-intermediate/01-concurrency/02-context-in-go/#contextwithtimeoutparentcontext-duration","title":"<code>context.WithTimeout(parentContext, duration)</code>","text":"<ul> <li>Creates a context that cancels itself after a specified timeout.</li> </ul> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    // Create a context with a timeout of 2 seconds\n    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)\n    defer cancel() // Always call cancel to release resources\n\n    select {\n    case &lt;-time.After(3 * time.Second):\n        fmt.Println(\"Operation completed\")\n    case &lt;-ctx.Done():\n        fmt.Println(\"Timeout occurred:\", ctx.Err())\n    }\n}\n</code></pre>"},{"location":"02-intermediate/01-concurrency/02-context-in-go/#contextwithdeadlineparentcontext-deadlinetime","title":"<code>context.WithDeadline(parentContext, deadlineTime)</code>","text":"<ul> <li>Similar to <code>WithTimeout</code>, but specifies an exact deadline instead of a duration.</li> </ul> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    // Set a specific deadline\n    deadline := time.Now().Add(2 * time.Second)\n    ctx, cancel := context.WithDeadline(context.Background(), deadline)\n    defer cancel()\n\n    select {\n    case &lt;-time.After(3 * time.Second):\n        fmt.Println(\"Operation completed\")\n    case &lt;-ctx.Done():\n        fmt.Println(\"Deadline exceeded:\", ctx.Err())\n    }\n}\n</code></pre>"},{"location":"02-intermediate/01-concurrency/02-context-in-go/#passing-values-in-context","title":"Passing Values in Context","text":"<ul> <li>Use <code>context.WithValue(parentContext, key, value)</code> to pass data along with the context.</li> <li>Not intended for frequently accessed data; use it sparingly.</li> </ul> <pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n)\n\nfunc main() {\n    // Create a context with a value\n    ctx := context.WithValue(context.Background(), \"userID\", 42)\n\n    // Pass the context to a function\n    process(ctx)\n}\n\nfunc process(ctx context.Context) {\n    userID := ctx.Value(\"userID\")\n    if userID != nil {\n        fmt.Println(\"User ID:\", userID)\n    } else {\n        fmt.Println(\"No user ID found\")\n    }\n}\n</code></pre>"},{"location":"02-intermediate/01-concurrency/02-context-in-go/#key-functions-in-context","title":"Key Functions in Context","text":"Function Description <code>ctx.Done()</code> Returns a channel that is closed when the context is canceled or times out. <code>ctx.Err()</code> Returns an error indicating why the context was canceled (e.g., <code>canceled</code> or <code>deadline exceeded</code>). <code>ctx.Value(key)</code> Retrieves the value associated with the context for a given key."},{"location":"02-intermediate/01-concurrency/02-context-in-go/#using-context-in-goroutines","title":"Using Context in Goroutines","text":"<p>Contexts are especially useful for managing goroutines, ensuring they are terminated when no longer needed.</p>"},{"location":"02-intermediate/01-concurrency/02-context-in-go/#example-goroutine-with-timeout","title":"Example: Goroutine with Timeout","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"time\"\n)\n\nfunc main() {\n    ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)\n    defer cancel()\n\n    go longRunningTask(ctx)\n\n    // Wait for context to timeout\n    time.Sleep(4 * time.Second)\n    fmt.Println(\"Main function exiting\")\n}\n\nfunc longRunningTask(ctx context.Context) {\n    for {\n        select {\n        case &lt;-ctx.Done():\n            fmt.Println(\"Task canceled:\", ctx.Err())\n            return\n        default:\n            fmt.Println(\"Working...\")\n            time.Sleep(1 * time.Second)\n        }\n    }\n}\n</code></pre>"},{"location":"02-intermediate/01-concurrency/02-context-in-go/#best-practices-with-context","title":"Best Practices with Context","text":"<ol> <li>Always Cancel Contexts:</li> <li> <p>Call <code>cancel()</code> for <code>WithCancel</code>, <code>WithTimeout</code>, and <code>WithDeadline</code> to avoid resource leaks.</p> </li> <li> <p>Pass Context Explicitly:</p> </li> <li> <p>Pass the context as the first argument to functions that need it.</p> </li> <li> <p>Avoid Passing Context Across Tiers:</p> </li> <li> <p>Context should not be passed to multiple layers unnecessarily.</p> </li> <li> <p>Do Not Store Context in Structs:</p> </li> <li> <p>Pass it explicitly to each function instead.</p> </li> <li> <p>Minimal Use of <code>WithValue</code>:</p> </li> <li>Use for request-scoped data; avoid for large or frequently accessed data.</li> </ol>"},{"location":"02-intermediate/01-concurrency/02-context-in-go/#advanced-topics","title":"Advanced Topics","text":"<ol> <li> <p>Rate Limiting with Context:    Use <code>time.Ticker</code> in conjunction with <code>ctx.Done()</code> to limit the rate of operations.</p> </li> <li> <p>Buffered Channels with Context:    Allow goroutines to process a limited number of tasks, with graceful shutdown.</p> </li> <li> <p>Context with HTTP Handlers:    Use <code>ctx</code> to propagate deadlines, timeouts, or cancellation in web servers.</p> </li> </ol>"},{"location":"02-intermediate/01-concurrency/02-context-in-go/#example-http-server-with-context","title":"Example: HTTP Server with Context","text":"<pre><code>package main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"net/http\"\n    \"time\"\n)\n\nfunc main() {\n    http.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n        ctx, cancel := context.WithTimeout(r.Context(), 2*time.Second)\n        defer cancel()\n\n        done := make(chan bool)\n        go func() {\n            // Simulate processing\n            time.Sleep(3 * time.Second)\n            done &lt;- true\n        }()\n\n        select {\n        case &lt;-ctx.Done():\n            http.Error(w, \"Request timed out\", http.StatusRequestTimeout)\n        case &lt;-done:\n            fmt.Fprintln(w, \"Request processed successfully\")\n        }\n    })\n\n    fmt.Println(\"Server starting on :8080\")\n    http.ListenAndServe(\":8080\", nil)\n}\n</code></pre>"},{"location":"02-intermediate/01-concurrency/03-atomic-operations/","title":"Why Use Atomic Operations?","text":"<p>Atomic operations provide:</p> <ul> <li>Thread-safety without needing explicit locks (<code>sync.Mutex</code>), improving performance.</li> <li>Low-level primitives to manipulate memory directly, ensuring correctness in concurrent environments.</li> <li>Efficient updates to variables, avoiding the overhead of context switching caused by locking.</li> </ul>"},{"location":"02-intermediate/01-concurrency/03-atomic-operations/#commonly-used-atomic-functions","title":"Commonly Used Atomic Functions","text":"<p>Here are some key atomic functions provided by the <code>sync/atomic</code> package:</p> <ol> <li>Atomic Load: Safely reads a value.</li> <li> <p><code>LoadInt32</code>, <code>LoadInt64</code>, <code>LoadUint32</code>, <code>LoadUint64</code>, <code>LoadPointer</code></p> </li> <li> <p>Atomic Store: Safely writes a value.</p> </li> <li> <p><code>StoreInt32</code>, <code>StoreInt64</code>, <code>StoreUint32</code>, <code>StoreUint64</code>, <code>StorePointer</code></p> </li> <li> <p>Atomic Swap: Replaces a value atomically and returns the old value.</p> </li> <li> <p><code>SwapInt32</code>, <code>SwapInt64</code>, <code>SwapUint32</code>, <code>SwapUint64</code>, <code>SwapPointer</code></p> </li> <li> <p>Atomic Add: Safely increments or decrements a value.</p> </li> <li> <p><code>AddInt32</code>, <code>AddInt64</code>, <code>AddUint32</code>, <code>AddUint64</code></p> </li> <li> <p>Compare-And-Swap (CAS): Compares a value and swaps it only if it matches the expected value.</p> </li> <li><code>CompareAndSwapInt32</code>, <code>CompareAndSwapInt64</code>, <code>CompareAndSwapUint32</code>, <code>CompareAndSwapUint64</code>, <code>CompareAndSwapPointer</code></li> </ol>"},{"location":"02-intermediate/01-concurrency/03-atomic-operations/#examples-of-atomic-operations","title":"Examples of Atomic Operations","text":""},{"location":"02-intermediate/01-concurrency/03-atomic-operations/#1-atomic-counter","title":"1. Atomic Counter","text":"<p>Incrementing a shared counter across multiple goroutines safely:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n    \"sync/atomic\"\n)\n\nfunc main() {\n    var counter int64 // Shared counter\n    var wg sync.WaitGroup\n\n    // Launch 10 goroutines, each incrementing the counter 100 times\n    for i := 0; i &lt; 10; i++ {\n        wg.Add(1)\n        go func() {\n            defer wg.Done()\n            for j := 0; j &lt; 100; j++ {\n                atomic.AddInt64(&amp;counter, 1)\n            }\n        }()\n    }\n\n    wg.Wait()\n    fmt.Println(\"Final Counter:\", counter) // Should print 1000\n}\n</code></pre>"},{"location":"02-intermediate/01-concurrency/03-atomic-operations/#2-compare-and-swap-cas","title":"2. Compare-And-Swap (CAS)","text":"<p>Ensures atomicity when setting a variable conditionally:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync/atomic\"\n)\n\nfunc main() {\n    var value int32 = 42\n\n    // Compare and swap value only if it matches expected value\n    swapped := atomic.CompareAndSwapInt32(&amp;value, 42, 100)\n    fmt.Println(\"Swapped:\", swapped)  // true\n    fmt.Println(\"Value:\", value)      // 100\n\n    // Fails because the current value is no longer 42\n    swapped = atomic.CompareAndSwapInt32(&amp;value, 42, 200)\n    fmt.Println(\"Swapped:\", swapped)  // false\n    fmt.Println(\"Value:\", value)      // 100\n}\n</code></pre>"},{"location":"02-intermediate/01-concurrency/03-atomic-operations/#3-atomic-swap","title":"3. Atomic Swap","text":"<p>Replace a value and retrieve the old one atomically:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync/atomic\"\n)\n\nfunc main() {\n    var value int64 = 10\n\n    oldValue := atomic.SwapInt64(&amp;value, 50)\n    fmt.Println(\"Old Value:\", oldValue) // 10\n    fmt.Println(\"New Value:\", value)    // 50\n}\n</code></pre>"},{"location":"02-intermediate/01-concurrency/03-atomic-operations/#4-atomic-load-and-store","title":"4. Atomic Load and Store","text":"<p>Safely read and write shared variables:</p> <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync/atomic\"\n)\n\nfunc main() {\n    var value int64 = 42\n\n    // Load the current value\n    current := atomic.LoadInt64(&amp;value)\n    fmt.Println(\"Loaded Value:\", current) // 42\n\n    // Store a new value\n    atomic.StoreInt64(&amp;value, 99)\n    fmt.Println(\"Updated Value:\", value)  // 99\n}\n</code></pre>"},{"location":"02-intermediate/01-concurrency/03-atomic-operations/#when-to-use-atomic-operations","title":"When to Use Atomic Operations","text":"<ol> <li>Simple Counters or Flags: Use atomic operations for counters, toggles, or status flags in a lightweight way.</li> <li>Performance-Sensitive Scenarios: If locks are slowing down performance, atomic operations provide a fast, lock-free alternative.</li> <li>Shared State Updates: Safely update shared data between goroutines when full synchronization is not needed.</li> </ol>"},{"location":"02-intermediate/01-concurrency/03-atomic-operations/#when-not-to-use-atomic-operations","title":"When NOT to Use Atomic Operations","text":"<ol> <li>Complex Data Structures: Atomic operations work only on individual variables. For more complex data, consider using <code>sync.Mutex</code> or <code>sync.RWMutex</code>.</li> <li>Read-Heavy Operations: Use <code>sync.RWMutex</code> if reads significantly outweigh writes, as atomic operations don\u2019t optimize for reads.</li> </ol>"},{"location":"02-intermediate/01-concurrency/03-atomic-operations/#advanced-use-cases","title":"Advanced Use Cases","text":"<ol> <li>Atomic Value: Use <code>sync/atomic.Value</code> to store and load any value (not just numeric types) safely.</li> <li> <p>Example:    <pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync/atomic\"\n)\n\nfunc main() {\n    var value atomic.Value\n\n    value.Store(\"Hello, Go!\")\n    fmt.Println(\"Loaded Value:\", value.Load()) // Hello, Go!\n}\n</code></pre></p> </li> <li> <p>Building Lock-Free Data Structures: Atomic primitives are the building blocks for lock-free data structures, like queues or stacks, but they require deeper understanding and careful design.</p> </li> </ol>"},{"location":"02-intermediate/01-concurrency/03-atomic-operations/#summary","title":"Summary","text":"<ul> <li>Atomic operations in Go are lightweight, efficient, and ideal for managing simple shared states in concurrent programs.</li> <li>While they are not a replacement for higher-level synchronization primitives (like mutexes), they are indispensable for performance-critical or low-level concurrency tasks.</li> <li>Mastering these will strengthen your understanding of how Go handles memory and synchronization under the hood.</li> </ul>"},{"location":"02-intermediate/01-concurrency/04-fan-out-and-fan-in-pattern/","title":"Fan-In and Fan-Out Patterns in Go","text":"<p>Fan-In and Fan-Out are common concurrency patterns that involve managing data flow between multiple goroutines. Here's a breakdown:</p>"},{"location":"02-intermediate/01-concurrency/04-fan-out-and-fan-in-pattern/#fan-out-pattern","title":"Fan-Out Pattern","text":"<p>Fan-Out is the process of distributing tasks to multiple worker goroutines for parallel processing. It helps utilize multiple CPU cores effectively.</p>"},{"location":"02-intermediate/01-concurrency/04-fan-out-and-fan-in-pattern/#example-fan-out","title":"Example: Fan-Out","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\nfunc worker(id int, jobs &lt;-chan int, results chan&lt;- int, wg *sync.WaitGroup) {\n    defer wg.Done()\n    for job := range jobs {\n        fmt.Printf(\"Worker %d processing job %d\\n\", id, job)\n        time.Sleep(time.Second) // Simulate work\n        results &lt;- job * 2      // Send result back\n    }\n}\n\nfunc main() {\n    const numWorkers = 3\n    const numJobs = 10\n\n    jobs := make(chan int, numJobs)\n    results := make(chan int, numJobs)\n\n    var wg sync.WaitGroup\n\n    // Start worker goroutines\n    for i := 1; i &lt;= numWorkers; i++ {\n        wg.Add(1)\n        go worker(i, jobs, results, &amp;wg)\n    }\n\n    // Send jobs to workers\n    for j := 1; j &lt;= numJobs; j++ {\n        jobs &lt;- j\n    }\n    close(jobs)\n\n    // Wait for all workers to complete\n    wg.Wait()\n    close(results)\n\n    // Collect results\n    for result := range results {\n        fmt.Println(\"Result:\", result)\n    }\n}\n</code></pre>"},{"location":"02-intermediate/01-concurrency/04-fan-out-and-fan-in-pattern/#fan-in-pattern","title":"Fan-In Pattern","text":"<p>Fan-In is the process of combining results from multiple channels into a single channel. It consolidates concurrent outputs into one stream.</p>"},{"location":"02-intermediate/01-concurrency/04-fan-out-and-fan-in-pattern/#example-fan-in","title":"Example: Fan-In","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nfunc generateNumbers(name string, ch chan&lt;- int) {\n    for i := 0; i &lt; 5; i++ {\n        fmt.Printf(\"%s sending: %d\\n\", name, i)\n        ch &lt;- i\n        time.Sleep(500 * time.Millisecond) // Simulate processing time\n    }\n    close(ch)\n}\n\nfunc fanIn(ch1, ch2 &lt;-chan int) &lt;-chan int {\n    out := make(chan int)\n    go func() {\n        for v := range ch1 {\n            out &lt;- v\n        }\n    }()\n    go func() {\n        for v := range ch2 {\n            out &lt;- v\n        }\n    }()\n    return out\n}\n\nfunc main() {\n    ch1 := make(chan int)\n    ch2 := make(chan int)\n\n    go generateNumbers(\"Source1\", ch1)\n    go generateNumbers(\"Source2\", ch2)\n\n    merged := fanIn(ch1, ch2)\n\n    for v := range merged {\n        fmt.Println(\"Received:\", v)\n    }\n}\n</code></pre>"},{"location":"02-intermediate/01-concurrency/04-fan-out-and-fan-in-pattern/#fan-in-and-fan-out-combined","title":"Fan-In and Fan-Out Combined","text":"<p>A real-world application often uses both patterns together. For example:</p> <ol> <li>A Fan-Out distributes work to multiple workers.</li> <li>The workers' results are then merged using Fan-In.</li> </ol>"},{"location":"02-intermediate/01-concurrency/04-fan-out-and-fan-in-pattern/#example-combining-fan-in-and-fan-out","title":"Example: Combining Fan-In and Fan-Out","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\nfunc worker(id int, jobs &lt;-chan int, results chan&lt;- int) {\n    for job := range jobs {\n        fmt.Printf(\"Worker %d processing job %d\\n\", id, job)\n        time.Sleep(time.Second) // Simulate work\n        results &lt;- job * 2      // Send processed result\n    }\n}\n\nfunc fanIn(chs ...&lt;-chan int) &lt;-chan int {\n    out := make(chan int)\n    var wg sync.WaitGroup\n\n    for _, ch := range chs {\n        wg.Add(1)\n        go func(c &lt;-chan int) {\n            defer wg.Done()\n            for v := range c {\n                out &lt;- v\n            }\n        }(ch)\n    }\n\n    go func() {\n        wg.Wait()\n        close(out)\n    }()\n\n    return out\n}\n\nfunc main() {\n    const numWorkers = 3\n    const numJobs = 6\n\n    jobs := make(chan int, numJobs)\n    resultChans := make([]chan int, numWorkers)\n\n    // Create worker result channels\n    for i := 0; i &lt; numWorkers; i++ {\n        resultChans[i] = make(chan int, numJobs/numWorkers)\n        go worker(i+1, jobs, resultChans[i])\n    }\n\n    // Distribute jobs\n    go func() {\n        for j := 1; j &lt;= numJobs; j++ {\n            jobs &lt;- j\n        }\n        close(jobs)\n    }()\n\n    // Merge results from all workers\n    mergedResults := fanIn(resultChans...)\n\n    // Collect and print merged results\n    for result := range mergedResults {\n        fmt.Println(\"Final Result:\", result)\n    }\n}\n</code></pre>"},{"location":"02-intermediate/01-concurrency/04-fan-out-and-fan-in-pattern/#key-notes","title":"Key Notes","text":"<p>Fan-Out</p> <ul> <li>Ensures work is distributed among multiple goroutines for parallelism.</li> <li>Use buffered channels to avoid blocking, if needed.</li> </ul> <p>Fan-In</p> <ul> <li>Combines multiple streams into a single stream.</li> <li>Use <code>sync.WaitGroup</code> or closing channels to ensure all results are collected.</li> </ul> <p>Practical Use Cases</p> <ul> <li>Fan-Out: Web crawling, data processing.</li> <li>Fan-In: Aggregating logs, consolidating API responses.</li> </ul>"},{"location":"02-intermediate/01-concurrency/05-synchronization/","title":"Synchronization","text":""},{"location":"02-intermediate/01-concurrency/05-synchronization/#synchronization-in-go","title":"Synchronization in Go","text":"<p>Synchronization ensures that goroutines coordinate properly and avoid conflicts, especially when accessing shared resources. Go provides multiple mechanisms for synchronization:</p>"},{"location":"02-intermediate/01-concurrency/05-synchronization/#1-syncmutex","title":"1. sync.Mutex","text":"<p><code>sync.Mutex</code> is used to lock and unlock critical sections to ensure only one goroutine accesses shared data at a time.</p>"},{"location":"02-intermediate/01-concurrency/05-synchronization/#example-mutex-for-shared-counter","title":"Example: Mutex for Shared Counter","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nfunc main() {\n    var mu sync.Mutex\n    counter := 0\n\n    var wg sync.WaitGroup\n    const numGoroutines = 5\n\n    for i := 0; i &lt; numGoroutines; i++ {\n        wg.Add(1)\n        go func(id int) {\n            defer wg.Done()\n            mu.Lock()\n            counter++\n            fmt.Printf(\"Goroutine %d incremented counter to %d\\n\", id, counter)\n            mu.Unlock()\n        }(i)\n    }\n\n    wg.Wait()\n    fmt.Println(\"Final Counter:\", counter)\n}\n</code></pre>"},{"location":"02-intermediate/01-concurrency/05-synchronization/#2-syncrwmutex","title":"2. sync.RWMutex","text":"<p><code>sync.RWMutex</code> provides separate locks for reading and writing: - Multiple readers can acquire the lock simultaneously. - Only one writer can acquire the lock, blocking readers and other writers.</p>"},{"location":"02-intermediate/01-concurrency/05-synchronization/#example-rwmutex-for-read-and-write","title":"Example: RWMutex for Read and Write","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nfunc main() {\n    var mu sync.RWMutex\n    data := make(map[int]string)\n\n    var wg sync.WaitGroup\n\n    // Writer\n    wg.Add(1)\n    go func() {\n        defer wg.Done()\n        mu.Lock()\n        data[1] = \"GoLang\"\n        fmt.Println(\"Write: Added GoLang\")\n        mu.Unlock()\n    }()\n\n    // Reader\n    wg.Add(1)\n    go func() {\n        defer wg.Done()\n        mu.RLock()\n        fmt.Println(\"Read: Value for key 1 is\", data[1])\n        mu.RUnlock()\n    }()\n\n    wg.Wait()\n}\n</code></pre>"},{"location":"02-intermediate/01-concurrency/05-synchronization/#3-syncwaitgroup","title":"3. sync.WaitGroup","text":"<p><code>sync.WaitGroup</code> waits for multiple goroutines to complete.</p>"},{"location":"02-intermediate/01-concurrency/05-synchronization/#example-using-waitgroup","title":"Example: Using WaitGroup","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\nfunc worker(id int, wg *sync.WaitGroup) {\n    defer wg.Done() // Decrement counter when goroutine finishes\n    fmt.Printf(\"Worker %d starting\\n\", id)\n    time.Sleep(time.Second) // Simulate work\n    fmt.Printf(\"Worker %d done\\n\", id)\n}\n\nfunc main() {\n    var wg sync.WaitGroup\n\n    for i := 1; i &lt;= 3; i++ {\n        wg.Add(1) // Increment counter for each goroutine\n        go worker(i, &amp;wg)\n    }\n\n    wg.Wait() // Block until all workers are done\n    fmt.Println(\"All workers finished\")\n}\n</code></pre>"},{"location":"02-intermediate/01-concurrency/05-synchronization/#4-synccond","title":"4. sync.Cond","text":"<p><code>sync.Cond</code> allows goroutines to signal each other. Useful for scenarios like producer-consumer.</p>"},{"location":"02-intermediate/01-concurrency/05-synchronization/#example-using-synccond","title":"Example: Using sync.Cond","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n    \"time\"\n)\n\nfunc main() {\n    var mu sync.Mutex\n    cond := sync.NewCond(&amp;mu)\n    queue := make([]int, 0)\n\n    const maxQueueSize = 3\n\n    // Consumer\n    go func() {\n        for {\n            mu.Lock()\n            for len(queue) == 0 {\n                cond.Wait() // Wait until there's something to consume\n            }\n            item := queue[0]\n            queue = queue[1:]\n            fmt.Println(\"Consumed:\", item)\n            cond.Signal() // Notify producers\n            mu.Unlock()\n        }\n    }()\n\n    // Producer\n    go func() {\n        for i := 1; i &lt;= 5; i++ {\n            mu.Lock()\n            for len(queue) &gt;= maxQueueSize {\n                cond.Wait() // Wait until there's space\n            }\n            queue = append(queue, i)\n            fmt.Println(\"Produced:\", i)\n            cond.Signal() // Notify consumers\n            mu.Unlock()\n            time.Sleep(time.Millisecond * 500)\n        }\n    }()\n\n    // Let the program run for a while\n    time.Sleep(time.Second * 5)\n}\n</code></pre>"},{"location":"02-intermediate/01-concurrency/05-synchronization/#5-synconce","title":"5. sync.Once","text":"<p><code>sync.Once</code> ensures that a piece of code runs only once, no matter how many goroutines invoke it.</p>"},{"location":"02-intermediate/01-concurrency/05-synchronization/#example-using-synconce","title":"Example: Using sync.Once","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nfunc main() {\n    var once sync.Once\n\n    initFunc := func() {\n        fmt.Println(\"Initialization done\")\n    }\n\n    for i := 0; i &lt; 3; i++ {\n        go func(id int) {\n            fmt.Printf(\"Goroutine %d calling init\\n\", id)\n            once.Do(initFunc) // Only the first call runs initFunc\n        }(i)\n    }\n\n    // Wait for goroutines to complete\n    time.Sleep(time.Second)\n}\n</code></pre>"},{"location":"02-intermediate/01-concurrency/05-synchronization/#6-atomic-operations","title":"6. Atomic Operations","text":"<p>The <code>sync/atomic</code> package provides low-level primitives for atomic operations like incrementing or swapping values without locks.</p>"},{"location":"02-intermediate/01-concurrency/05-synchronization/#example-atomic-counter","title":"Example: Atomic Counter","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync/atomic\"\n)\n\nfunc main() {\n    var counter int64\n\n    const numGoroutines = 10\n    done := make(chan bool, numGoroutines)\n\n    for i := 0; i &lt; numGoroutines; i++ {\n        go func() {\n            for j := 0; j &lt; 1000; j++ {\n                atomic.AddInt64(&amp;counter, 1) // Atomically increment counter\n            }\n            done &lt;- true\n        }()\n    }\n\n    for i := 0; i &lt; numGoroutines; i++ {\n        &lt;-done\n    }\n\n    fmt.Println(\"Final Counter:\", counter)\n}\n</code></pre>"},{"location":"02-intermediate/01-concurrency/05-synchronization/#7-channel-based-synchronization","title":"7. Channel-Based Synchronization","text":"<p>Channels are a high-level and idiomatic way to synchronize goroutines.</p>"},{"location":"02-intermediate/01-concurrency/05-synchronization/#example-using-channels-for-synchronization","title":"Example: Using Channels for Synchronization","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc worker(done chan bool) {\n    fmt.Println(\"Working...\")\n    done &lt;- true // Notify main goroutine\n}\n\nfunc main() {\n    done := make(chan bool)\n    go worker(done)\n\n    &lt;-done // Wait for worker to finish\n    fmt.Println(\"Worker finished\")\n}\n</code></pre>"},{"location":"02-intermediate/01-concurrency/05-synchronization/#when-to-use-what","title":"When to Use What","text":"Scenario Synchronization Mechanism Mutual exclusion (read/write) <code>sync.Mutex</code>, <code>sync.RWMutex</code> Waiting for multiple goroutines <code>sync.WaitGroup</code> Triggering once-only execution <code>sync.Once</code> Fine-grained atomic updates <code>sync/atomic</code> Coordinating producer/consumer <code>sync.Cond</code>, Channels"},{"location":"02-intermediate/01-concurrency/05-synchronization/#key-takeaways","title":"Key Takeaways","text":"<ul> <li>Use channels for idiomatic Go synchronization.</li> <li>Use mutexes for critical sections when channels are not suitable.</li> <li>Avoid over-synchronizing; keep designs simple and focused on performance.</li> </ul>"},{"location":"02-intermediate/01-concurrency/06-deadlock-and-race-conditions/","title":"Deadlock & Race Conditions","text":""},{"location":"02-intermediate/01-concurrency/06-deadlock-and-race-conditions/#deadlocks-and-race-conditions-in-go","title":"Deadlocks and Race Conditions in Go","text":"<p>Concurrency brings challenges like deadlocks and race conditions, which can lead to improper program behavior or complete system failure.</p>"},{"location":"02-intermediate/01-concurrency/06-deadlock-and-race-conditions/#1-deadlocks","title":"1. Deadlocks","text":"<p>A deadlock occurs when two or more goroutines wait indefinitely for each other to release a resource, and none can proceed.</p>"},{"location":"02-intermediate/01-concurrency/06-deadlock-and-race-conditions/#common-causes-of-deadlocks","title":"Common Causes of Deadlocks","text":"<ul> <li>Holding multiple locks in inconsistent order.</li> <li>Goroutines waiting on each other to signal indefinitely.</li> <li>Forgetting to release locks or send signals.</li> </ul>"},{"location":"02-intermediate/01-concurrency/06-deadlock-and-race-conditions/#example-deadlock-with-mutex","title":"Example: Deadlock with Mutex","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nfunc main() {\n    var mu sync.Mutex\n\n    // Goroutine 1 locks and waits\n    go func() {\n        mu.Lock()\n        defer mu.Unlock()\n\n        fmt.Println(\"Goroutine 1 locked\")\n        // Simulate some work\n    }()\n\n    // Main goroutine locks and waits\n    mu.Lock()\n    defer mu.Unlock()\n\n    fmt.Println(\"Main goroutine locked\")\n}\n</code></pre> <p>Output: The program deadlocks because both goroutines are waiting for each other to unlock.</p>"},{"location":"02-intermediate/01-concurrency/06-deadlock-and-race-conditions/#how-to-prevent-deadlocks","title":"How to Prevent Deadlocks","text":"<ol> <li>Avoid nested locks.    Minimize locking multiple resources simultaneously.  </li> <li>Use channels.    Channels can help avoid explicit locking mechanisms.  </li> <li>Lock in a consistent order.    Always acquire locks in the same sequence to prevent cyclic waits.  </li> <li>Use <code>sync.TryLock</code>.    Avoid blocking indefinitely when acquiring a lock.</li> </ol>"},{"location":"02-intermediate/01-concurrency/06-deadlock-and-race-conditions/#example-resolving-deadlock-with-channels","title":"Example: Resolving Deadlock with Channels","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    ch := make(chan int)\n\n    // Send and receive in separate goroutines\n    go func() {\n        ch &lt;- 1\n    }()\n\n    val := &lt;-ch\n    fmt.Println(\"Received value:\", val)\n}\n</code></pre>"},{"location":"02-intermediate/01-concurrency/06-deadlock-and-race-conditions/#2-race-conditions","title":"2. Race Conditions","text":"<p>A race condition occurs when multiple goroutines access shared resources concurrently, and at least one of them modifies the data, leading to unpredictable outcomes.</p>"},{"location":"02-intermediate/01-concurrency/06-deadlock-and-race-conditions/#detecting-race-conditions","title":"Detecting Race Conditions","text":"<ul> <li>Go Race Detector   Run your program with <code>go run -race .</code>; It reports race conditions in real-time.  </li> </ul>"},{"location":"02-intermediate/01-concurrency/06-deadlock-and-race-conditions/#example-race-condition","title":"Example: Race Condition","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"time\"\n)\n\nvar counter int\n\nfunc increment() {\n    for i := 0; i &lt; 1000; i++ {\n        counter++\n    }\n}\n\nfunc main() {\n    go increment()\n    go increment()\n\n    time.Sleep(time.Second) // Wait for goroutines to complete\n    fmt.Println(\"Final Counter:\", counter)\n}\n</code></pre> <p>Output: The final counter value varies on different executions due to simultaneous modifications by multiple goroutines.</p>"},{"location":"02-intermediate/01-concurrency/06-deadlock-and-race-conditions/#how-to-prevent-race-conditions","title":"How to Prevent Race Conditions","text":"<ol> <li>Use Mutex:    Protect critical sections using <code>sync.Mutex</code>.  </li> <li>Use Atomic Operations:    Leverage <code>sync/atomic</code> for low-level thread-safe operations.  </li> <li>Use Channels:    Pass data between goroutines via channels instead of shared variables.</li> </ol>"},{"location":"02-intermediate/01-concurrency/06-deadlock-and-race-conditions/#example-resolving-race-with-mutex","title":"Example: Resolving Race with Mutex","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\nvar counter int\nvar mu sync.Mutex\n\nfunc increment() {\n    for i := 0; i &lt; 1000; i++ {\n        mu.Lock()\n        counter++\n        mu.Unlock()\n    }\n}\n\nfunc main() {\n    var wg sync.WaitGroup\n\n    wg.Add(2)\n    go func() {\n        defer wg.Done()\n        increment()\n    }()\n    go func() {\n        defer wg.Done()\n        increment()\n    }()\n\n    wg.Wait()\n    fmt.Println(\"Final Counter:\", counter)\n}\n</code></pre>"},{"location":"02-intermediate/01-concurrency/06-deadlock-and-race-conditions/#example-resolving-race-with-atomic-operations","title":"Example: Resolving Race with Atomic Operations","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"sync/atomic\"\n)\n\nvar counter int64\n\nfunc increment() {\n    for i := 0; i &lt; 1000; i++ {\n        atomic.AddInt64(&amp;counter, 1)\n    }\n}\n\nfunc main() {\n    done := make(chan bool, 2)\n\n    go func() {\n        increment()\n        done &lt;- true\n    }()\n    go func() {\n        increment()\n        done &lt;- true\n    }()\n\n    &lt;-done\n    &lt;-done\n    fmt.Println(\"Final Counter:\", counter)\n}\n</code></pre>"},{"location":"02-intermediate/01-concurrency/06-deadlock-and-race-conditions/#key-differences-deadlock-vs-race-condition","title":"Key Differences: Deadlock vs Race Condition","text":"Aspect Deadlock Race Condition Cause Waiting indefinitely for resource release. Concurrent access to shared resources. Symptom Program hangs or freezes. Program exhibits unpredictable behavior. Detection Easily reproducible with static analysis. Requires dynamic analysis (<code>go run -race  .</code>). Solution Proper locking, ordering, or avoiding cycles. Synchronization via locks, channels, or atomic."},{"location":"02-intermediate/01-concurrency/06-deadlock-and-race-conditions/#best-practices-to-avoid-both","title":"Best Practices to Avoid Both","text":"<ol> <li>Use Go's Race Detector: Regularly test using <code>-race</code> to catch potential issues.</li> <li>Prefer Channels Over Locks: Channels often simplify communication without explicit synchronization.</li> <li>Minimize Shared State: Design your program to avoid sharing data among goroutines whenever possible.</li> <li>Document Goroutine Interaction: Ensure clear documentation of how goroutines coordinate and share resources.</li> </ol>"},{"location":"02-intermediate/02-interface-generic-reflection/01-interfaces/","title":"Interfaces","text":""},{"location":"02-intermediate/02-interface-generic-reflection/01-interfaces/#interfaces-in-go","title":"Interfaces in Go","text":"<p>An interface in Go specifies a method set and allows you to define the behavior that types must implement. Interfaces are a cornerstone of polymorphism in Go.</p>"},{"location":"02-intermediate/02-interface-generic-reflection/01-interfaces/#1-declaring-an-interface","title":"1. Declaring an Interface","text":"<p>An interface is declared using the <code>type</code> keyword, followed by its name and method set.</p>"},{"location":"02-intermediate/02-interface-generic-reflection/01-interfaces/#example-simple-interface","title":"Example: Simple Interface","text":"<pre><code>package main\n\nimport \"fmt\"\n\n// Define an interface\ntype Shape interface {\n    Area() float64\n    Perimeter() float64\n}\n\n// Implement the interface in a type\ntype Rectangle struct {\n    Width, Height float64\n}\n\nfunc (r Rectangle) Area() float64 {\n    return r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n    return 2 * (r.Width + r.Height)\n}\n\nfunc main() {\n    var s Shape = Rectangle{Width: 5, Height: 10}\n    fmt.Println(\"Area:\", s.Area())\n    fmt.Println(\"Perimeter:\", s.Perimeter())\n}\n</code></pre>"},{"location":"02-intermediate/02-interface-generic-reflection/01-interfaces/#2-empty-interface","title":"2. Empty Interface","text":"<p>The empty interface (<code>interface{}</code>) can hold values of any type. It is commonly used when the type is not known at compile time.</p>"},{"location":"02-intermediate/02-interface-generic-reflection/01-interfaces/#example-using-interface","title":"Example: Using <code>interface{}</code>","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc describe(i interface{}) {\n    fmt.Printf(\"Type: %T, Value: %v\\n\", i, i)\n}\n\nfunc main() {\n    describe(42)\n    describe(\"hello\")\n    describe(true)\n}\n</code></pre>"},{"location":"02-intermediate/02-interface-generic-reflection/01-interfaces/#3-type-assertions","title":"3. Type Assertions","text":"<p>Type assertions are used to extract the underlying value of an interface.</p>"},{"location":"02-intermediate/02-interface-generic-reflection/01-interfaces/#syntax","title":"Syntax:","text":"<pre><code>value := i.(T) // Asserts that the interface `i` holds a value of type `T`\n</code></pre>"},{"location":"02-intermediate/02-interface-generic-reflection/01-interfaces/#example-safe-type-assertion","title":"Example: Safe Type Assertion","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n    var i interface{} = \"hello\"\n\n    // Safe assertion\n    if str, ok := i.(string); ok {\n        fmt.Println(\"String value:\", str)\n    } else {\n        fmt.Println(\"Not a string\")\n    }\n}\n</code></pre>"},{"location":"02-intermediate/02-interface-generic-reflection/01-interfaces/#4-type-switch","title":"4. Type Switch","text":"<p>A type switch allows you to handle multiple types stored in an interface.</p>"},{"location":"02-intermediate/02-interface-generic-reflection/01-interfaces/#example-type-switch","title":"Example: Type Switch","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc process(i interface{}) {\n    switch v := i.(type) {\n    case string:\n        fmt.Println(\"String value:\", v)\n    case int:\n        fmt.Println(\"Integer value:\", v)\n    default:\n        fmt.Println(\"Unknown type\")\n    }\n}\n\nfunc main() {\n    process(\"hello\")\n    process(42)\n    process(3.14)\n}\n</code></pre>"},{"location":"02-intermediate/02-interface-generic-reflection/01-interfaces/#5-interface-composition","title":"5. Interface Composition","text":"<p>Go supports interface composition, allowing you to combine multiple interfaces into one.</p>"},{"location":"02-intermediate/02-interface-generic-reflection/01-interfaces/#example-composed-interface","title":"Example: Composed Interface","text":"<pre><code>package main\n\nimport \"fmt\"\n\n// Define two interfaces\ntype Reader interface {\n    Read() string\n}\n\ntype Writer interface {\n    Write(data string)\n}\n\n// Compose Reader and Writer\ntype ReadWriter interface {\n    Reader\n    Writer\n}\n\ntype File struct {\n    content string\n}\n\nfunc (f *File) Read() string {\n    return f.content\n}\n\nfunc (f *File) Write(data string) {\n    f.content = data\n}\n\nfunc main() {\n    var rw ReadWriter = &amp;File{}\n\n    rw.Write(\"Hello, Go!\")\n    fmt.Println(\"Content:\", rw.Read())\n}\n</code></pre>"},{"location":"02-intermediate/02-interface-generic-reflection/01-interfaces/#6-nil-interfaces","title":"6. Nil Interfaces","text":"<p>An interface with a <code>nil</code> value behaves differently based on its underlying type.</p>"},{"location":"02-intermediate/02-interface-generic-reflection/01-interfaces/#example-nil-interface-behavior","title":"Example: Nil Interface Behavior","text":"<pre><code>package main\n\nimport \"fmt\"\n\ntype Printer interface {\n    Print()\n}\n\ntype ConsolePrinter struct{}\n\nfunc (c *ConsolePrinter) Print() {\n    fmt.Println(\"Printing...\")\n}\n\nfunc main() {\n    var p Printer\n\n    if p == nil {\n        fmt.Println(\"Interface is nil\")\n    }\n\n    p = &amp;ConsolePrinter{}\n    p.Print()\n}\n</code></pre>"},{"location":"02-intermediate/02-interface-generic-reflection/01-interfaces/#7-practical-use-cases","title":"7. Practical Use Cases","text":"<ul> <li>Polymorphism: Interfaces allow functions to work with multiple types that implement the same interface.</li> <li>Dependency Injection: Pass interfaces to functions to increase testability and decouple implementations.</li> <li>Mocking: Use interfaces to mock dependencies in tests.</li> </ul>"},{"location":"02-intermediate/02-interface-generic-reflection/01-interfaces/#8-common-interface-examples-in-gos-standard-library","title":"8. Common Interface Examples in Go's Standard Library","text":"Interface Description <code>fmt.Stringer</code> Defines the <code>String() string</code> method for custom string formatting. <code>io.Reader</code> Represents types that can read data. <code>io.Writer</code> Represents types that can write data. <code>error</code> Represents types that can return error messages (<code>Error() string</code>)."},{"location":"02-intermediate/02-interface-generic-reflection/01-interfaces/#example-fmtstringer","title":"Example: <code>fmt.Stringer</code>","text":"<pre><code>package main\n\nimport \"fmt\"\n\ntype Person struct {\n    Name string\n    Age  int\n}\n\nfunc (p Person) String() string {\n    return fmt.Sprintf(\"Name: %s, Age: %d\", p.Name, p.Age)\n}\n\nfunc main() {\n    p := Person{Name: \"Alice\", Age: 25}\n    fmt.Println(p)\n}\n</code></pre>"},{"location":"02-intermediate/02-interface-generic-reflection/01-interfaces/#best-practices-with-interfaces","title":"Best Practices with Interfaces","text":"<ol> <li>Keep Interfaces Small: Prefer single-method interfaces (e.g., <code>io.Reader</code>) for flexibility.</li> <li>Name Interfaces after Behavior: Use verbs or roles like <code>Reader</code>, <code>Writer</code>, or <code>Closer</code>.</li> <li>Design for Contracts: Ensure interfaces represent meaningful contracts for types.</li> <li>Avoid Empty Interfaces: Use <code>interface{}</code> sparingly; prefer concrete types when possible.</li> </ol>"},{"location":"02-intermediate/02-interface-generic-reflection/02-generics/","title":"Generics","text":""},{"location":"02-intermediate/02-interface-generic-reflection/02-generics/#generics-in-go","title":"Generics in Go","text":"<p>Generics were introduced in Go 1.18 to enable functions and types to operate on multiple types while maintaining type safety. Generics provide a way to write reusable, type-agnostic code without sacrificing the performance and simplicity Go is known for.</p>"},{"location":"02-intermediate/02-interface-generic-reflection/02-generics/#1-basics-of-generics","title":"1. Basics of Generics","text":"<p>Generics in Go are implemented using type parameters. A type parameter is a placeholder for a type that is provided when the function or type is instantiated.</p>"},{"location":"02-intermediate/02-interface-generic-reflection/02-generics/#example-generic-function","title":"Example: Generic Function","text":"<pre><code>package main\n\nimport \"fmt\"\n\n// Generic function with a type parameter T\nfunc Print[T any](value T) {\n    fmt.Println(value)\n}\n\nfunc main() {\n    Print(42)\n    Print(\"Hello, Generics!\")\n    Print(3.14)\n}\n</code></pre> <ul> <li><code>[T any]</code>: Declares a type parameter <code>T</code> that can be any type.</li> </ul>"},{"location":"02-intermediate/02-interface-generic-reflection/02-generics/#2-type-constraints","title":"2. Type Constraints","text":"<p>You can constrain type parameters to ensure they satisfy specific behaviors or methods. Constraints are defined using interfaces.</p>"},{"location":"02-intermediate/02-interface-generic-reflection/02-generics/#example-constrained-generics","title":"Example: Constrained Generics","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n)\n\n// Constrain T to numeric types\ntype Numeric interface {\n    int | int8 | int16 | int32 | int64 | float32 | float64\n}\n\nfunc Add[T Numeric](a, b T) T {\n    return a + b\n}\n\nfunc main() {\n    fmt.Println(Add(5, 10))       // Works with int\n    fmt.Println(Add(3.14, 2.71)) // Works with float64\n}\n</code></pre>"},{"location":"02-intermediate/02-interface-generic-reflection/02-generics/#3-generic-types","title":"3. Generic Types","text":"<p>Structs and other types can also use type parameters.</p>"},{"location":"02-intermediate/02-interface-generic-reflection/02-generics/#example-generic-struct","title":"Example: Generic Struct","text":"<pre><code>package main\n\nimport \"fmt\"\n\n// Generic struct\ntype Stack[T any] struct {\n    elements []T\n}\n\nfunc (s *Stack[T]) Push(value T) {\n    s.elements = append(s.elements, value)\n}\n\nfunc (s *Stack[T]) Pop() T {\n    if len(s.elements) == 0 {\n        panic(\"Stack is empty\")\n    }\n    last := s.elements[len(s.elements)-1]\n    s.elements = s.elements[:len(s.elements)-1]\n    return last\n}\n\nfunc main() {\n    var intStack Stack[int]\n    intStack.Push(10)\n    intStack.Push(20)\n    fmt.Println(intStack.Pop()) // Output: 20\n    fmt.Println(intStack.Pop()) // Output: 10\n\n    var stringStack Stack[string]\n    stringStack.Push(\"Go\")\n    stringStack.Push(\"Generics\")\n    fmt.Println(stringStack.Pop()) // Output: Generics\n}\n</code></pre>"},{"location":"02-intermediate/02-interface-generic-reflection/02-generics/#4-multiple-type-parameters","title":"4. Multiple Type Parameters","text":"<p>You can use multiple type parameters to generalize more complex behaviors.</p>"},{"location":"02-intermediate/02-interface-generic-reflection/02-generics/#example-multiple-type-parameters","title":"Example: Multiple Type Parameters","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc Combine[K, V any](key K, value V) (K, V) {\n    return key, value\n}\n\nfunc main() {\n    k, v := Combine(\"ID\", 12345)\n    fmt.Printf(\"Key: %v, Value: %v\\n\", k, v)\n}\n</code></pre>"},{"location":"02-intermediate/02-interface-generic-reflection/02-generics/#5-constraints-with-methods","title":"5. Constraints with Methods","text":"<p>If a constraint interface defines methods, the type parameter must implement them.</p>"},{"location":"02-intermediate/02-interface-generic-reflection/02-generics/#example-constraints-with-methods","title":"Example: Constraints with Methods","text":"<pre><code>package main\n\nimport \"fmt\"\n\n// Constrain to types implementing fmt.Stringer\ntype Stringer interface {\n    String() string\n}\n\nfunc PrintString[T Stringer](value T) {\n    fmt.Println(value.String())\n}\n\ntype Person struct {\n    Name string\n    Age  int\n}\n\nfunc (p Person) String() string {\n    return fmt.Sprintf(\"Name: %s, Age: %d\", p.Name, p.Age)\n}\n\nfunc main() {\n    p := Person{Name: \"Alice\", Age: 30}\n    PrintString(p)\n}\n</code></pre>"},{"location":"02-intermediate/02-interface-generic-reflection/02-generics/#6-standard-library-support","title":"6. Standard Library Support","text":"<p>Generics are integrated into the Go standard library. For example, <code>constraints</code> is a package that provides ready-made constraints.</p>"},{"location":"02-intermediate/02-interface-generic-reflection/02-generics/#common-constraints","title":"Common Constraints:","text":"<ul> <li><code>constraints.Ordered</code>: For types that support <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>.</li> </ul>"},{"location":"02-intermediate/02-interface-generic-reflection/02-generics/#example-sorting-with-ordered-constraint","title":"Example: Sorting with Ordered Constraint","text":"<pre><code>package main\n\nimport (\n    \"constraints\"\n    \"fmt\"\n)\n\nfunc Min[T constraints.Ordered](a, b T) T {\n    if a &lt; b {\n        return a\n    }\n    return b\n}\n\nfunc main() {\n    fmt.Println(Min(10, 20))       // Works with integers\n    fmt.Println(Min(3.14, 2.71))  // Works with floats\n    fmt.Println(Min(\"a\", \"b\"))    // Works with strings\n}\n</code></pre>"},{"location":"02-intermediate/02-interface-generic-reflection/02-generics/#7-generic-maps-and-slices","title":"7. Generic Maps and Slices","text":"<p>Generics allow building reusable utilities for common operations on collections like maps and slices.</p>"},{"location":"02-intermediate/02-interface-generic-reflection/02-generics/#example-filter-a-slice","title":"Example: Filter a Slice","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc Filter[T any](data []T, predicate func(T) bool) []T {\n    var result []T\n    for _, v := range data {\n        if predicate(v) {\n            result = append(result, v)\n        }\n    }\n    return result\n}\n\nfunc main() {\n    nums := []int{1, 2, 3, 4, 5}\n    even := Filter(nums, func(n int) bool { return n%2 == 0 })\n    fmt.Println(even) // Output: [2 4]\n}\n</code></pre>"},{"location":"02-intermediate/02-interface-generic-reflection/02-generics/#8-generics-and-performance","title":"8. Generics and Performance","text":"<p>While generics provide flexibility, they may introduce slight performance overhead due to type instantiations. However, Go's compiler optimizes generic code, so the difference is usually negligible.</p>"},{"location":"02-intermediate/02-interface-generic-reflection/02-generics/#best-practices-with-generics","title":"Best Practices with Generics","text":"<ol> <li>Use When Necessary: Avoid overusing generics; use them when they simplify your code or reduce duplication.</li> <li>Leverage Constraints: Use meaningful constraints to guide type usage.</li> <li>Keep It Readable: Overly complex generic declarations can harm readability.</li> <li>Stick to Go\u2019s Simplicity: Generics should enhance, not replace, Go's idiomatic patterns.</li> </ol>"},{"location":"02-intermediate/02-interface-generic-reflection/02-generics/#additional-topics-to-explore","title":"Additional Topics to Explore","text":"<ul> <li>Generic Interface Constraints</li> <li>Comparisons Between Generics and Reflection</li> <li>Advanced Patterns like Generics with Recursive Types</li> </ul>"},{"location":"02-intermediate/02-interface-generic-reflection/03-reflection/","title":"Reflection","text":""},{"location":"02-intermediate/02-interface-generic-reflection/03-reflection/#reflection-in-go","title":"Reflection in Go","text":"<p>Reflection in Go allows you to inspect and manipulate the types of objects at runtime. It is a powerful feature that can be used for tasks like serialization, logging, testing, and other meta-programming tasks. Reflection is implemented in Go via the <code>reflect</code> package.</p> <p>Reflection is useful when you need to handle arbitrary types in a dynamic way, but it comes with a performance cost and reduces type safety, so it should be used carefully.</p>"},{"location":"02-intermediate/02-interface-generic-reflection/03-reflection/#1-the-reflect-package","title":"1. The <code>reflect</code> Package","text":"<p>The <code>reflect</code> package provides mechanisms to work with types and values at runtime. The two primary types in reflection are:</p> <ul> <li><code>reflect.Type</code>: Represents the type of a value.</li> <li><code>reflect.Value</code>: Represents the value of a variable.</li> </ul>"},{"location":"02-intermediate/02-interface-generic-reflection/03-reflection/#2-getting-type-and-value-with-reflection","title":"2. Getting Type and Value with Reflection","text":"<p>To work with reflection, we typically use <code>reflect.TypeOf()</code> to get the type of an object and <code>reflect.ValueOf()</code> to get the value of an object.</p>"},{"location":"02-intermediate/02-interface-generic-reflection/03-reflection/#example-using-reflecttypeof-and-reflectvalueof","title":"Example: Using <code>reflect.TypeOf()</code> and <code>reflect.ValueOf()</code>","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n)\n\nfunc main() {\n    var x int = 42\n    var y float64 = 3.14\n    var s string = \"Hello, reflection!\"\n\n    // Get type and value of variables\n    fmt.Println(\"Type of x:\", reflect.TypeOf(x))\n    fmt.Println(\"Value of x:\", reflect.ValueOf(x))\n\n    fmt.Println(\"Type of y:\", reflect.TypeOf(y))\n    fmt.Println(\"Value of y:\", reflect.ValueOf(y))\n\n    fmt.Println(\"Type of s:\", reflect.TypeOf(s))\n    fmt.Println(\"Value of s:\", reflect.ValueOf(s))\n}\n</code></pre> <p>Output: <pre><code>Type of x: int\nValue of x: 42\nType of y: float64\nValue of y: 3.14\nType of s: string\nValue of s: Hello, reflection!\n</code></pre></p>"},{"location":"02-intermediate/02-interface-generic-reflection/03-reflection/#3-getting-and-modifying-struct-fields-using-reflection","title":"3. Getting and Modifying Struct Fields Using Reflection","text":"<p>You can also manipulate struct fields using reflection. To do this, the struct must be passed by pointer to allow modifications.</p>"},{"location":"02-intermediate/02-interface-generic-reflection/03-reflection/#example-accessing-struct-fields","title":"Example: Accessing Struct Fields","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n)\n\ntype Person struct {\n    Name string\n    Age  int\n}\n\nfunc main() {\n    p := Person{Name: \"Alice\", Age: 30}\n\n    // Get type and value of the struct\n    v := reflect.ValueOf(&amp;p).Elem()\n    t := v.Type()\n\n    // Access struct fields by name\n    for i := 0; i &lt; v.NumField(); i++ {\n        fmt.Printf(\"%s: %v\\n\", t.Field(i).Name, v.Field(i).Interface())\n    }\n\n    // Modify the fields using reflection\n    v.FieldByName(\"Name\").SetString(\"Bob\")\n    v.FieldByName(\"Age\").SetInt(35)\n\n    fmt.Println(\"Updated person:\", p)\n}\n</code></pre> <p>Output: <pre><code>Name: Alice\nAge: 30\nUpdated person: {Bob 35}\n</code></pre></p> <ul> <li><code>Elem()</code>: Dereferences the pointer to access the struct.</li> <li><code>NumField()</code>: Gets the number of fields in the struct.</li> <li><code>Field(i)</code>: Gets a field by index.</li> <li><code>SetString()</code> and <code>SetInt()</code>: Used to modify the values of struct fields.</li> </ul>"},{"location":"02-intermediate/02-interface-generic-reflection/03-reflection/#4-reflection-with-interfaces","title":"4. Reflection with Interfaces","text":"<p>You can use reflection with interfaces, but it's important to note that Go\u2019s interface values can hold both the type and the value, so they require a bit more work to inspect.</p>"},{"location":"02-intermediate/02-interface-generic-reflection/03-reflection/#example-working-with-interface-values","title":"Example: Working with Interface Values","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n)\n\nfunc printTypeAndValue(i interface{}) {\n    v := reflect.ValueOf(i)\n    t := reflect.TypeOf(i)\n\n    fmt.Println(\"Type:\", t)\n    fmt.Println(\"Value:\", v)\n}\n\nfunc main() {\n    var x int = 42\n    var y string = \"hello\"\n\n    printTypeAndValue(x)\n    printTypeAndValue(y)\n}\n</code></pre> <p>Output: <pre><code>Type: int\nValue: 42\nType: string\nValue: hello\n</code></pre></p> <ul> <li><code>reflect.ValueOf()</code>: Gets the value of an interface.</li> <li><code>reflect.TypeOf()</code>: Gets the type of an interface.</li> </ul>"},{"location":"02-intermediate/02-interface-generic-reflection/03-reflection/#5-reflection-and-interfaces-with-method-invocation","title":"5. Reflection and Interfaces with Method Invocation","text":"<p>You can also use reflection to invoke methods on structs.</p>"},{"location":"02-intermediate/02-interface-generic-reflection/03-reflection/#example-calling-methods-with-reflection","title":"Example: Calling Methods with Reflection","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n)\n\ntype Person struct {\n    Name string\n}\n\nfunc (p Person) Greet() {\n    fmt.Println(\"Hello, \" + p.Name)\n}\n\nfunc main() {\n    p := Person{Name: \"Alice\"}\n\n    // Get value of the struct and method\n    v := reflect.ValueOf(p)\n    method := v.MethodByName(\"Greet\")\n\n    // Call method via reflection\n    if method.IsValid() {\n        method.Call(nil)\n    } else {\n        fmt.Println(\"Method not found!\")\n    }\n}\n</code></pre> <p>Output: <pre><code>Hello, Alice\n</code></pre></p> <ul> <li><code>MethodByName()</code>: Returns a method by name.</li> <li><code>Call()</code>: Invokes the method. If the method requires arguments, they can be passed as a slice of <code>reflect.Value</code>.</li> </ul>"},{"location":"02-intermediate/02-interface-generic-reflection/03-reflection/#6-reflection-and-type-assertions","title":"6. Reflection and Type Assertions","text":"<p>Reflection allows you to perform type assertions dynamically.</p>"},{"location":"02-intermediate/02-interface-generic-reflection/03-reflection/#example-type-assertions-using-reflection","title":"Example: Type Assertions Using Reflection","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n)\n\nfunc printTypeAndAssert(i interface{}) {\n    v := reflect.ValueOf(i)\n\n    if v.Kind() == reflect.Int {\n        fmt.Println(\"The value is an int:\", v.Int())\n    } else if v.Kind() == reflect.String {\n        fmt.Println(\"The value is a string:\", v.String())\n    } else {\n        fmt.Println(\"Unknown type\")\n    }\n}\n\nfunc main() {\n    var x int = 42\n    var y string = \"hello\"\n\n    printTypeAndAssert(x)\n    printTypeAndAssert(y)\n}\n</code></pre> <p>Output: <pre><code>The value is an int: 42\nThe value is a string: hello\n</code></pre></p> <ul> <li><code>Kind()</code>: Returns the kind of a value (e.g., <code>reflect.Int</code>, <code>reflect.String</code>).</li> <li><code>Int()</code> and <code>String()</code>: Return the underlying value of the respective type.</li> </ul>"},{"location":"02-intermediate/02-interface-generic-reflection/03-reflection/#7-limitations-and-caution-with-reflection","title":"7. Limitations and Caution with Reflection","text":"<ol> <li> <p>Performance Overhead: Reflection adds runtime overhead due to type inspection and value manipulation. Avoid excessive use in performance-critical applications.</p> </li> <li> <p>Reduced Type Safety: Reflection bypasses Go's strong type checking, which can introduce bugs or unexpected behaviors if not handled carefully.</p> </li> <li> <p>Complexity: Reflection can make code harder to understand and maintain due to the dynamic nature of type handling.</p> </li> </ol>"},{"location":"02-intermediate/02-interface-generic-reflection/03-reflection/#8-use-cases-for-reflection","title":"8. Use Cases for Reflection","text":"<p>Reflection is used in Go in various scenarios where the type of an object cannot be known until runtime:</p> <ul> <li>Serialization (e.g., JSON encoding/decoding): Libraries like <code>encoding/json</code> use reflection to handle different struct types dynamically.</li> <li>Testing: Reflection allows for dynamic test case generation and introspection of test results.</li> <li>ORMs: Reflection is used by Object-Relational Mappers to automatically map struct fields to database columns.</li> <li>Dependency Injection and Mocking: Reflection is useful in scenarios where the dependency graph of objects must be dynamically created.</li> </ul>"},{"location":"02-intermediate/02-interface-generic-reflection/03-reflection/#conclusion","title":"Conclusion","text":"<p>Reflection is a powerful tool in Go, but it should be used judiciously. It allows you to work with unknown types at runtime, but it introduces runtime overhead and reduces type safety. For most use cases, Go\u2019s strong type system should be preferred, and reflection should only be used when absolutely necessary.</p>"},{"location":"03-advanced/01-conditional-compilation/","title":"Conditional Compilation in Go","text":"<p>We can run different code based on the operating system or architecture using conditional compilation.</p>"},{"location":"03-advanced/01-conditional-compilation/#running-on-different-operating-systems","title":"Running on Different Operating Systems","text":"<pre><code>my_project/\n\u251c\u2500\u2500 main.go\n\u2514\u2500\u2500 helper_darwin.go\n\u2514\u2500\u2500 helper_linux.go\n</code></pre> <p>If we can a function that is defined in both <code>helper_darwin.go</code> and <code>helper_linux.go</code>, and we run the program on a different operating system, the function will be called from the correct file.</p>"},{"location":"03-advanced/01-conditional-compilation/#running-on-different-architectures","title":"Running on Different Architectures","text":"<p>Go provides us with build tags to run different code based on the architecture.</p> <pre><code>my_project/\n\u251c\u2500\u2500 main.go\n\u2514\u2500\u2500 helper_mac_m1.go\n\u2514\u2500\u2500 helper_mac_intel.go\n</code></pre> <ul> <li><code>helper_mac_m1.go</code> file</li> </ul> <pre><code>//+build darwin,arm64\n\npackage main\n\nimport \"fmt\"\n\nfunc checker_func(){\n    fmt.Println(\"running on mac silicon\")\n}\n</code></pre> <ul> <li><code>helper_mac_intel.go</code> file</li> </ul> <pre><code>//+build darwin,!arm64\n\npackage main\n\nimport \"fmt\"\n\nfunc checker_func(){\n    fmt.Println(\"running on mac intel\")\n}\n</code></pre>"},{"location":"03-advanced/01-conditional-compilation/#new-build-tag","title":"New <code>build tag</code>","text":"<p>Many new codebases also use <code>build tag</code> to run different code based on the operating system or architecture.</p> <pre><code>//go:build darwin &amp;&amp; arm64\n\npackage main\n\nimport \"fmt\"\n\nfunc checker_func(){\n    fmt.Println(\"running on mac silicon\")\n}\n</code></pre>"},{"location":"04-cool-packages/01-flags/","title":"<code>flag</code> Module in Go","text":"<p>The <code>flag</code> module in Go is used for parsing command-line arguments. It provides a way to define and use flags in your program.</p>"},{"location":"04-cool-packages/01-flags/#basic-example","title":"Basic Example","text":"<pre><code>package main\n\nimport (\n    \"flag\"\n    \"fmt\"\n)\n\nfunc main() {\n    // Define flags\n    name := flag.String(\"name\", \"World\", \"a name to say hello to\")\n    age := flag.Int(\"age\", 0, \"your age\")\n    isMember := flag.Bool(\"member\", false, \"are you a member?\")\n\n    // Parse the flags\n    flag.Parse()\n\n    // Access the values\n    fmt.Printf(\"Hello, %s! Age: %d, Member: %t\\n\", *name, *age, *isMember) // we need to dereference pointers\n\n    // Remaining command-line arguments\n    fmt.Println(\"Other arguments:\", flag.Args())\n}\n</code></pre> <ul> <li>Output</li> </ul> <pre><code>go run main.go -name=Deep -age=22 -member=true extra_arg\n</code></pre> <p>You would get: <pre><code>Hello, Deep! Age: 23, Member: true\nOther arguments: [extra_arg]\n</code></pre></p> <ul> <li>The one weird thing is that, we need to dereference the pointers to get the actual values.</li> </ul>"},{"location":"04-cool-packages/01-flags/#better-flag-usage","title":"Better flag usage","text":"<ul> <li>We can use <code>flag.IntVar</code> instead of <code>flag.Int</code>. But, here we need to pass a pointer to the variable.</li> </ul> <pre><code>package main\n\nimport (\n    \"flag\"\n    \"fmt\"\n)\n\nfunc main() {\n    var worker int\n    flag.IntVar(&amp;worker, \"worker\", 0, \"Number of worker\")\n\n    flag.Parse()\n\n    fmt.Println(\"Number of workers is: \", worker)\n}\n</code></pre>"},{"location":"04-cool-packages/01-flags/#help-command","title":"Help command","text":"<ul> <li>we can use <code>-h</code> or <code>--help</code> to see auto-generated usage information:</li> </ul> <pre><code>go run . -h \n# or\ngo run . --help\n</code></pre>"},{"location":"04-cool-packages/01-flags/#flags-with-structs-good-example","title":"Flags with Structs (Good example)","text":"<pre><code>package main\n\nimport (\n    \"flag\"\n    \"fmt\"\n)\n\ntype ServerConfig struct {\n    port    int\n    workers int\n    env     string\n}\n\nfunc main() {\n    conf := ServerConfig{}\n\n    flag.IntVar(&amp;conf.port, \"port\", 6969, \"which port to run on\")\n    flag.IntVar(&amp;conf.workers, \"worker\", 1, \"number of workers to run\")\n    flag.StringVar(&amp;conf.env, \"env\", \"dev\", \"which mode server is in: dev | prod\")\n\n    flag.Parse()\n\n    fmt.Printf(\"%+v\\n\", conf)\n}\n</code></pre> <ul> <li>Run it:</li> </ul> <pre><code>go run . -port=8080 -worker=2 -env=prod\n\n# Output\n{port:8080 workers:2 env:prod}\n</code></pre>"}]}